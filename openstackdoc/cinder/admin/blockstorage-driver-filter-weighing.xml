<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document source="/home/fbaumanis/openstack/soc8_test/openstack_repo/cinder/doc/source/admin/blockstorage-driver-filter-weighing.rst">
    <target refid="filter-weigh-scheduler"></target>
    <section ids="configure-and-use-driver-filter-and-weighing-for-scheduler filter-weigh-scheduler" names="configure\ and\ use\ driver\ filter\ and\ weighing\ for\ scheduler filter_weigh_scheduler">
        <title>Configure and use driver filter and weighing for scheduler</title>
        <paragraph>OpenStack Block Storage enables you to choose a volume back end based on
            back-end specific properties by using the DriverFilter and
            GoodnessWeigher for the scheduler. The driver filter and weigher
            scheduling can help ensure that the scheduler chooses the best back end
            based on requested volume properties as well as various back-end
            specific properties.</paragraph>
        <section ids="what-is-driver-filter-and-weigher-and-when-to-use-it" names="what\ is\ driver\ filter\ and\ weigher\ and\ when\ to\ use\ it">
            <title>What is driver filter and weigher and when to use it</title>
            <paragraph>The driver filter and weigher gives you the ability to more finely
                control how the OpenStack Block Storage scheduler chooses the best back
                end to use when handling a volume request. One example scenario where
                using the driver filter and weigher can be if a back end that utilizes
                thin-provisioning is used. The default filters use the <literal>free capacity</literal>
                property to determine the best back end, but that is not always perfect.
                If a back end has the ability to provide a more accurate back-end
                specific value you can use that as part of the weighing. Another example
                of when the driver filter and weigher can prove useful is if a back end
                exists where there is a hard limit of 1000 volumes. The maximum volume
                size is 500Â GB. Once 75% of the total space is occupied the performance
                of the back end degrades. The driver filter and weigher can provide a
                way for these limits to be checked for.</paragraph>
        </section>
        <section ids="enable-driver-filter-and-weighing" names="enable\ driver\ filter\ and\ weighing">
            <title>Enable driver filter and weighing</title>
            <paragraph>To enable the driver filter, set the <literal>scheduler_default_filters</literal> option in
                the <literal>cinder.conf</literal> file to <literal>DriverFilter</literal> or add it to the list if
                other filters are already present.</paragraph>
            <paragraph>To enable the goodness filter as a weigher, set the
                <literal>scheduler_default_weighers</literal> option in the <literal>cinder.conf</literal> file to
                <literal>GoodnessWeigher</literal> or add it to the list if other weighers are already
                present.</paragraph>
            <paragraph>You can choose to use the <literal>DriverFilter</literal> without the
                <literal>GoodnessWeigher</literal> or vice-versa. The filter and weigher working
                together, however, create the most benefits when helping the scheduler
                choose an ideal back end.</paragraph>
            <important>
                <paragraph>The support for the <literal>DriverFilter</literal> and <literal>GoodnessWeigher</literal> is
                    optional for back ends. If you are using a back end that does not
                    support the filter and weigher functionality you may not get the
                    full benefit.</paragraph>
            </important>
            <paragraph>Example <literal>cinder.conf</literal> configuration file:</paragraph>
            <literal_block highlight_args="{}" language="ini" linenos="False" xml:space="preserve">scheduler_default_filters = DriverFilter
scheduler_default_weighers = GoodnessWeigher</literal_block>
            <note>
                <paragraph>It is useful to use the other filters and weighers available in
                    OpenStack in combination with these custom ones. For example, the
                    <literal>CapacityFilter</literal> and <literal>CapacityWeigher</literal> can be combined with
                    these.</paragraph>
            </note>
        </section>
        <section ids="defining-your-own-filter-and-goodness-functions" names="defining\ your\ own\ filter\ and\ goodness\ functions">
            <title>Defining your own filter and goodness functions</title>
            <paragraph>You can define your own filter and goodness functions through the use of
                various properties that OpenStack Block Storage has exposed. Properties
                exposed include information about the volume request being made,
                <literal>volume_type</literal> settings, and back-end specific information about drivers.
                All of these allow for a lot of control over how the ideal back end for
                a volume request will be decided.</paragraph>
            <paragraph>The <literal>filter_function</literal> option is a string defining an equation that
                will determine whether a back end should be considered as a potential
                candidate in the scheduler.</paragraph>
            <paragraph>The <literal>goodness_function</literal> option is a string defining an equation that
                will rate the quality of the potential host (0 to 100, 0 lowest, 100
                highest).</paragraph>
            <important>
                <paragraph>The drive filter and weigher will use default values for filter and
                    goodness functions for each back end if you do not define them
                    yourself. If complete control is desired then a filter and goodness
                    function should be defined for each of the back ends in
                    the <literal>cinder.conf</literal> file.</paragraph>
            </important>
        </section>
        <section ids="supported-operations-in-filter-and-goodness-functions" names="supported\ operations\ in\ filter\ and\ goodness\ functions">
            <title>Supported operations in filter and goodness functions</title>
            <paragraph>Below is a table of all the operations currently usable in custom filter
                and goodness functions created by you:</paragraph>
            <table>
                <tgroup cols="2">
                    <colspec colwidth="32"></colspec>
                    <colspec colwidth="25"></colspec>
                    <thead>
                        <row>
                            <entry>
                                <paragraph>Operations</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Type</paragraph>
                            </entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph>+, -, *, /, ^</paragraph>
                            </entry>
                            <entry>
                                <paragraph>standard math</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>not, and, or, &amp;, |, !</paragraph>
                            </entry>
                            <entry>
                                <paragraph>logic</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>&gt;, &gt;=, &lt;, &lt;=, ==, &lt;&gt;, !=</paragraph>
                            </entry>
                            <entry>
                                <paragraph>equality</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>+, -</paragraph>
                            </entry>
                            <entry>
                                <paragraph>sign</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>x ? a : b</paragraph>
                            </entry>
                            <entry>
                                <paragraph>ternary</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>abs(x), max(x, y), min(x, y)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>math helper functions</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <caution>
                <paragraph>Syntax errors you define in filter or goodness strings
                    are thrown at a volume request time.</paragraph>
            </caution>
        </section>
        <section ids="available-properties-when-creating-custom-functions" names="available\ properties\ when\ creating\ custom\ functions">
            <title>Available properties when creating custom functions</title>
            <paragraph>There are various properties that can be used in either the
                <literal>filter_function</literal> or the <literal>goodness_function</literal> strings. The properties allow
                access to volume info, qos settings, extra specs, and so on.</paragraph>
            <paragraph>The following properties and their sub-properties are currently
                available for use:</paragraph>
            <section ids="host-stats-for-a-back-end" names="host\ stats\ for\ a\ back\ end">
                <title>Host stats for a back end</title>
                <definition_list>
                    <definition_list_item>
                        <term>host</term>
                        <definition>
                            <paragraph>The hostâs name</paragraph>
                        </definition>
                    </definition_list_item>
                    <definition_list_item>
                        <term>volume_backend_name</term>
                        <definition>
                            <paragraph>The volume back end name</paragraph>
                        </definition>
                    </definition_list_item>
                    <definition_list_item>
                        <term>vendor_name</term>
                        <definition>
                            <paragraph>The vendor name</paragraph>
                        </definition>
                    </definition_list_item>
                    <definition_list_item>
                        <term>driver_version</term>
                        <definition>
                            <paragraph>The driver version</paragraph>
                        </definition>
                    </definition_list_item>
                    <definition_list_item>
                        <term>storage_protocol</term>
                        <definition>
                            <paragraph>The storage protocol</paragraph>
                        </definition>
                    </definition_list_item>
                    <definition_list_item>
                        <term>QoS_support</term>
                        <definition>
                            <paragraph>Boolean signifying whether QoS is supported</paragraph>
                        </definition>
                    </definition_list_item>
                    <definition_list_item>
                        <term>total_capacity_gb</term>
                        <definition>
                            <paragraph>The total capacity in GB</paragraph>
                        </definition>
                    </definition_list_item>
                    <definition_list_item>
                        <term>allocated_capacity_gb</term>
                        <definition>
                            <paragraph>The allocated capacity in GB</paragraph>
                        </definition>
                    </definition_list_item>
                    <definition_list_item>
                        <term>reserved_percentage</term>
                        <definition>
                            <paragraph>The reserved storage percentage</paragraph>
                        </definition>
                    </definition_list_item>
                </definition_list>
            </section>
            <section ids="capabilities-specific-to-a-back-end" names="capabilities\ specific\ to\ a\ back\ end">
                <title>Capabilities specific to a back end</title>
                <paragraph>These properties are determined by the specific back end
                    you are creating filter and goodness functions for. Some back ends
                    may not have any properties available here.</paragraph>
            </section>
            <section ids="requested-volume-properties" names="requested\ volume\ properties">
                <title>Requested volume properties</title>
                <definition_list>
                    <definition_list_item>
                        <term>status</term>
                        <definition>
                            <paragraph>Status for the requested volume</paragraph>
                        </definition>
                    </definition_list_item>
                    <definition_list_item>
                        <term>volume_type_id</term>
                        <definition>
                            <paragraph>The volume type ID</paragraph>
                        </definition>
                    </definition_list_item>
                    <definition_list_item>
                        <term>display_name</term>
                        <definition>
                            <paragraph>The display name of the volume</paragraph>
                        </definition>
                    </definition_list_item>
                    <definition_list_item>
                        <term>volume_metadata</term>
                        <definition>
                            <paragraph>Any metadata the volume has</paragraph>
                        </definition>
                    </definition_list_item>
                    <definition_list_item>
                        <term>reservations</term>
                        <definition>
                            <paragraph>Any reservations the volume has</paragraph>
                        </definition>
                    </definition_list_item>
                    <definition_list_item>
                        <term>user_id</term>
                        <definition>
                            <paragraph>The volumeâs user ID</paragraph>
                        </definition>
                    </definition_list_item>
                    <definition_list_item>
                        <term>attach_status</term>
                        <definition>
                            <paragraph>The attach status for the volume</paragraph>
                        </definition>
                    </definition_list_item>
                    <definition_list_item>
                        <term>display_description</term>
                        <definition>
                            <paragraph>The volumeâs display description</paragraph>
                        </definition>
                    </definition_list_item>
                    <definition_list_item>
                        <term>id</term>
                        <definition>
                            <paragraph>The volumeâs ID</paragraph>
                        </definition>
                    </definition_list_item>
                    <definition_list_item>
                        <term>replication_status</term>
                        <definition>
                            <paragraph>The volumeâs replication status</paragraph>
                        </definition>
                    </definition_list_item>
                    <definition_list_item>
                        <term>snapshot_id</term>
                        <definition>
                            <paragraph>The volumeâs snapshot ID</paragraph>
                        </definition>
                    </definition_list_item>
                    <definition_list_item>
                        <term>encryption_key_id</term>
                        <definition>
                            <paragraph>The volumeâs encryption key ID</paragraph>
                        </definition>
                    </definition_list_item>
                    <definition_list_item>
                        <term>source_volid</term>
                        <definition>
                            <paragraph>The source volume ID</paragraph>
                        </definition>
                    </definition_list_item>
                    <definition_list_item>
                        <term>volume_admin_metadata</term>
                        <definition>
                            <paragraph>Any admin metadata for this volume</paragraph>
                        </definition>
                    </definition_list_item>
                    <definition_list_item>
                        <term>source_replicaid</term>
                        <definition>
                            <paragraph>The source replication ID</paragraph>
                        </definition>
                    </definition_list_item>
                    <definition_list_item>
                        <term>consistencygroup_id</term>
                        <definition>
                            <paragraph>The consistency group ID</paragraph>
                        </definition>
                    </definition_list_item>
                    <definition_list_item>
                        <term>size</term>
                        <definition>
                            <paragraph>The size of the volume in GB</paragraph>
                        </definition>
                    </definition_list_item>
                    <definition_list_item>
                        <term>metadata</term>
                        <definition>
                            <paragraph>General metadata</paragraph>
                        </definition>
                    </definition_list_item>
                </definition_list>
                <paragraph>The property most used from here will most likely be the <literal>size</literal> sub-property.</paragraph>
            </section>
        </section>
        <section ids="extra-specs-for-the-requested-volume-type" names="extra\ specs\ for\ the\ requested\ volume\ type">
            <title>Extra specs for the requested volume type</title>
            <paragraph>View the available properties for volume types by running:</paragraph>
            <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve">$ cinder extra-specs-list</literal_block>
        </section>
        <section ids="current-qos-specs-for-the-requested-volume-type" names="current\ qos\ specs\ for\ the\ requested\ volume\ type">
            <title>Current QoS specs for the requested volume type</title>
            <paragraph>View the available properties for volume types by running:</paragraph>
            <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve">$ openstack volume qos list</literal_block>
            <paragraph>In order to access these properties in a custom string use the following
                format:</paragraph>
            <paragraph><literal>&lt;property&gt;.&lt;sub_property&gt;</literal></paragraph>
        </section>
        <section ids="driver-filter-and-weigher-usage-examples" names="driver\ filter\ and\ weigher\ usage\ examples">
            <title>Driver filter and weigher usage examples</title>
            <paragraph>Below are examples for using the filter and weigher separately,
                together, and using driver-specific properties.</paragraph>
            <paragraph>Example <literal>cinder.conf</literal> file configuration for customizing the filter
                function:</paragraph>
            <literal_block highlight_args="{}" language="ini" linenos="False" xml:space="preserve">[default]
scheduler_default_filters = DriverFilter
enabled_backends = lvm-1, lvm-2

[lvm-1]
volume_driver = cinder.volume.drivers.lvm.LVMVolumeDriver
volume_backend_name = sample_LVM01
filter_function = "volume.size &lt; 10"

[lvm-2]
volume_driver = cinder.volume.drivers.lvm.LVMVolumeDriver
volume_backend_name = sample_LVM02
filter_function = "volume.size &gt;= 10"</literal_block>
            <paragraph>The above example will filter volumes to different back ends depending
                on the size of the requested volume. Default OpenStack Block Storage
                scheduler weighing is done. Volumes with a size less than 10Â GB are sent
                to lvm-1 and volumes with a size greater than or equal to 10Â GB are sent
                to lvm-2.</paragraph>
            <paragraph>Example <literal>cinder.conf</literal> file configuration for customizing the goodness
                function:</paragraph>
            <literal_block highlight_args="{}" language="ini" linenos="False" xml:space="preserve">[default]
scheduler_default_weighers = GoodnessWeigher
enabled_backends = lvm-1, lvm-2

[lvm-1]
volume_driver = cinder.volume.drivers.lvm.LVMVolumeDriver
volume_backend_name = sample_LVM01
goodness_function = "(volume.size &lt; 5) ? 100 : 50"

[lvm-2]
volume_driver = cinder.volume.drivers.lvm.LVMVolumeDriver
volume_backend_name = sample_LVM02
goodness_function = "(volume.size &gt;= 5) ? 100 : 25"</literal_block>
            <paragraph>The above example will determine the goodness rating of a back end based
                off of the requested volumeâs size. Default OpenStack Block Storage
                scheduler filtering is done. The example shows how the ternary if
                statement can be used in a filter or goodness function. If a requested
                volume is of size 10Â GB then lvm-1 is rated as 50 and lvm-2 is rated as
                100. In this case lvm-2 wins. If a requested volume is of size 3Â GB then
                lvm-1 is rated 100 and lvm-2 is rated 25. In this case lvm-1 would win.</paragraph>
            <paragraph>Example <literal>cinder.conf</literal> file configuration for customizing both the
                filter and goodness functions:</paragraph>
            <literal_block highlight_args="{}" language="ini" linenos="False" xml:space="preserve">[default]
scheduler_default_filters = DriverFilter
scheduler_default_weighers = GoodnessWeigher
enabled_backends = lvm-1, lvm-2

[lvm-1]
volume_driver = cinder.volume.drivers.lvm.LVMVolumeDriver
volume_backend_name = sample_LVM01
filter_function = "stats.total_capacity_gb &lt; 500"
goodness_function = "(volume.size &lt; 25) ? 100 : 50"

[lvm-2]
volume_driver = cinder.volume.drivers.lvm.LVMVolumeDriver
volume_backend_name = sample_LVM02
filter_function = "stats.total_capacity_gb &gt;= 500"
goodness_function = "(volume.size &gt;= 25) ? 100 : 75"</literal_block>
            <paragraph>The above example combines the techniques from the first two examples.
                The best back end is now decided based off of the total capacity of the
                back end and the requested volumeâs size.</paragraph>
            <paragraph>Example <literal>cinder.conf</literal> file configuration for accessing driver specific
                properties:</paragraph>
            <literal_block highlight_args="{}" language="ini" linenos="False" xml:space="preserve">[default]
scheduler_default_filters = DriverFilter
scheduler_default_weighers = GoodnessWeigher
enabled_backends = lvm-1,lvm-2,lvm-3

[lvm-1]
volume_group = stack-volumes-lvmdriver-1
volume_driver = cinder.volume.drivers.lvm.LVMVolumeDriver
volume_backend_name = lvmdriver-1
filter_function = "volume.size &lt; 5"
goodness_function = "(capabilities.total_volumes &lt; 3) ? 100 : 50"

[lvm-2]
volume_group = stack-volumes-lvmdriver-2
volume_driver = cinder.volume.drivers.lvm.LVMVolumeDriver
volume_backend_name = lvmdriver-2
filter_function = "volumes.size &lt; 5"
goodness_function = "(capabilities.total_volumes &lt; 8) ? 100 : 50"

[lvm-3]
volume_group = stack-volumes-lvmdriver-3
volume_driver = cinder.volume.drivers.LVMVolumeDriver
volume_backend_name = lvmdriver-3
goodness_function = "55"</literal_block>
            <paragraph>The above is an example of how back-end specific properties can be used
                in the filter and goodness functions. In this example the LVM driverâs
                <literal>total_volumes</literal> capability is being used to determine which host gets
                used during a volume request. In the above example, lvm-1 and lvm-2 will
                handle volume requests for all volumes with a size less than 5Â GB. The
                lvm-1 host will have priority until it contains three or more volumes.
                After than lvm-2 will have priority until it contains eight or more
                volumes. The lvm-3 will collect all volumes greater or equal to 5Â GB as
                well as all volumes once lvm-1 and lvm-2 lose priority.</paragraph>
        </section>
    </section>
</document>
