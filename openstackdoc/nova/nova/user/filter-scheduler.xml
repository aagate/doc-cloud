<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document source="/home/fbaumanis/openstack/soc8_test/openstack_repo/nova/doc/source/user/filter-scheduler.rst">
    <section ids="filter-scheduler" names="filter\ scheduler">
        <title>Filter Scheduler</title>
        <paragraph>The <strong>Filter Scheduler</strong> supports <title_reference>filtering</title_reference> and <title_reference>weighting</title_reference> to make informed
            decisions on where a new instance should be created. This Scheduler supports
            working with Compute Nodes only.</paragraph>
        <section ids="filtering" names="filtering">
            <title>Filtering</title>
            <image candidates="{'*': u'_static/images/filtering-workflow-1.png'}" uri="_static/images/filtering-workflow-1.png"></image>
            <paragraph>During its work Filter Scheduler iterates over all found compute nodes,
                evaluating each against a set of filters. The list of resulting hosts is
                ordered by weighers. The Scheduler then chooses hosts for the requested
                number of instances, choosing the most weighted hosts. For a specific
                filter to succeed for a specific host, the filter matches the user
                request against the state of the host plus some extra magic as defined
                by each filter (described in more detail below).</paragraph>
            <paragraph>If the Scheduler cannot find candidates for the next instance, it means that
                there are no appropriate hosts where that instance can be scheduled.</paragraph>
            <paragraph>The Filter Scheduler has to be quite flexible to support the required variety
                of <title_reference>filtering</title_reference> and <title_reference>weighting</title_reference> strategies. If this flexibility is insufficient
                you can implement <title_reference>your own filtering algorithm</title_reference>.</paragraph>
            <paragraph>There are many standard filter classes which may be used
                (<literal classes="xref py py-mod">nova.scheduler.filters</literal>):</paragraph>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph><literal classes="xref py py-class">AllHostsFilter</literal> - does no filtering. It passes all the available hosts.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="xref py py-class">ImagePropertiesFilter</literal> - filters hosts based on properties defined
                        on the instance's image. It passes hosts that can support the properties
                        specified on the image used by the instance.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="xref py py-class">AvailabilityZoneFilter</literal> - filters hosts by availability zone. It passes
                        hosts matching the availability zone specified in the instance properties.
                        Use a comma to specify multiple zones. The filter will then ensure it matches
                        any zone specified.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="xref py py-class">ComputeCapabilitiesFilter</literal> - checks that the capabilities provided by the
                        host compute service satisfy any extra specifications associated with the
                        instance type. It passes hosts that can create the specified instance type.</paragraph>
                    <paragraph>If an extra specs key contains a colon (:), anything before the colon is
                        treated as a namespace and anything after the colon is treated as the key to
                        be matched. If a namespace is present and is not <literal>capabilities</literal>, the filter
                        ignores the namespace. For example <literal>capabilities:cpu_info:features</literal> is
                        a valid scope format. For backward compatibility, when a key doesn't contain
                        a colon (:), the key's contents are important. If this key is an attribute of
                        HostState object, like <literal>free_disk_mb</literal>, the filter also treats the extra
                        specs key as the key to be matched. If not, the filter will ignore the key.</paragraph>
                    <paragraph>The extra specifications can have an operator at the beginning of the value
                        string of a key/value pair. If there is no operator specified, then a
                        default operator of <literal>s==</literal> is used. Valid operators are:</paragraph>
                    <literal_block xml:space="preserve">* = (equal to or greater than as a number; same as vcpus case)
* == (equal to as a number)
* != (not equal to as a number)
* &gt;= (greater than or equal to as a number)
* &lt;= (less than or equal to as a number)
* s== (equal to as a string)
* s!= (not equal to as a string)
* s&gt;= (greater than or equal to as a string)
* s&gt; (greater than as a string)
* s&lt;= (less than or equal to as a string)
* s&lt; (less than as a string)
* &lt;in&gt; (substring)
* &lt;all-in&gt; (all elements contained in collection)
* &lt;or&gt; (find one of these)

Examples are: "&gt;= 5", "s== 2.1.0", "&lt;in&gt; gcc", "&lt;all-in&gt; aes mmx", and "&lt;or&gt; fpu &lt;or&gt; gpu"</literal_block>
                    <paragraph>some of attributes that can be used as useful key and their values contains:</paragraph>
                    <literal_block xml:space="preserve">* free_ram_mb (compared with a number, values like "&gt;= 4096")
* free_disk_mb (compared with a number, values like "&gt;= 10240")
* host (compared with a string, values like: "&lt;in&gt; compute","s== compute_01")
* hypervisor_type (compared with a string, values like: "s== QEMU", "s== powervm")
* hypervisor_version (compared with a number, values like : "&gt;= 1005003", "== 2000000")
* num_instances (compared with a number, values like: "&lt;= 10")
* num_io_ops (compared with a number, values like: "&lt;= 5")
* vcpus_total (compared with a number, values like: "= 48", "&gt;=24")
* vcpus_used (compared with a number, values like: "= 0", "&lt;= 10")</literal_block>
                </list_item>
                <list_item>
                    <paragraph><literal classes="xref py py-class">AggregateInstanceExtraSpecsFilter</literal> - checks that the aggregate metadata
                        satisfies any extra specifications associated with the instance type (that
                        have no scope or are scoped with <literal>aggregate_instance_extra_specs</literal>).
                        It passes hosts that can create the specified instance type.
                        The extra specifications can have the same operators as
                        <literal classes="xref py py-class">ComputeCapabilitiesFilter</literal>. To specify multiple values for the same key
                        use a comma. E.g., "value1,value2". All hosts are passed if no extra_specs
                        are specified.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="xref py py-class">ComputeFilter</literal> - passes all hosts that are operational and enabled.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="xref py py-class">CoreFilter</literal> - filters based on CPU core utilization. It passes hosts with
                        sufficient number of CPU cores.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="xref py py-class">AggregateCoreFilter</literal> - filters hosts by CPU core number with per-aggregate
                        <literal>cpu_allocation_ratio</literal> setting. If no per-aggregate value is found, it will
                        fall back to the global default <literal>cpu_allocation_ratio</literal>. If more than one value
                        is found for a host (meaning the host is in two different aggregates with
                        different ratio settings), the minimum value will be used.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="xref py py-class">IsolatedHostsFilter</literal> - filter based on <literal>isolated_images</literal>, <literal>isolated_hosts</literal>
                        and <literal>restrict_isolated_hosts_to_isolated_images</literal> flags.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="xref py py-class">JsonFilter</literal> - allows simple JSON-based grammar for selecting hosts.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="xref py py-class">RamFilter</literal> - filters hosts by their RAM. Only hosts with sufficient RAM
                        to host the instance are passed.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="xref py py-class">AggregateRamFilter</literal> - filters hosts by RAM with per-aggregate
                        <literal>ram_allocation_ratio</literal> setting. If no per-aggregate value is found, it will
                        fall back to the global default <literal>ram_allocation_ratio</literal>. If more than one value
                        is found for a host (meaning the host is in two different aggregates with
                        different ratio settings), the minimum value will be used.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="xref py py-class">DiskFilter</literal> - filters hosts by their disk allocation. Only hosts with sufficient
                        disk space to host the instance are passed.
                        <literal>disk_allocation_ratio</literal> setting. The virtual disk to physical disk
                        allocation ratio, 1.0 by default. The total allowed allocated disk size will
                        be physical disk multiplied this ratio.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="xref py py-class">AggregateDiskFilter</literal> - filters hosts by disk allocation with per-aggregate
                        <literal>disk_allocation_ratio</literal> setting. If no per-aggregate value is found, it will
                        fall back to the global default <literal>disk_allocation_ratio</literal>. If more than one value
                        is found for a host (meaning the host is in two or more different aggregates with
                        different ratio settings), the minimum value will be used.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="xref py py-class">NumInstancesFilter</literal> - filters compute nodes by number of running instances. Nodes
                        with too many instances will be filtered.
                        <literal>max_instances_per_host</literal> setting. Maximum number of instances allowed to run on
                        this host. The host will be ignored by the scheduler if more than <literal>max_instances_per_host</literal>
                        already exist on the host.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="xref py py-class">AggregateNumInstancesFilter</literal> - filters hosts by number of instances with
                        per-aggregate <literal>max_instances_per_host</literal> setting. If no per-aggregate value
                        is found, it will fall back to the global default <literal>max_instances_per_host</literal>.
                        If more than one value is found for a host (meaning the host is in two or more
                        different aggregates with different max instances per host settings),
                        the minimum value will be used.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="xref py py-class">IoOpsFilter</literal> - filters hosts by concurrent I/O operations on it.
                        hosts with too many concurrent I/O operations will be filtered.
                        <literal>max_io_ops_per_host</literal> setting. Maximum number of I/O intensive instances allowed to
                        run on this host, the host will be ignored by scheduler if more than <literal>max_io_ops_per_host</literal>
                        instances such as build/resize/snapshot etc are running on it.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="xref py py-class">AggregateIoOpsFilter</literal> - filters hosts by I/O operations with per-aggregate
                        <literal>max_io_ops_per_host</literal> setting. If no per-aggregate value is found, it will
                        fall back to the global default <literal>max_io_ops_per_host</literal>. If more than
                        one value is found for a host (meaning the host is in two or more different
                        aggregates with different max io operations settings), the minimum value
                        will be used.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="xref py py-class">PciPassthroughFilter</literal> - Filter that schedules instances on a host if the host
                        has devices to meet the device requests in the 'extra_specs' for the flavor.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="xref py py-class">SimpleCIDRAffinityFilter</literal> - allows a new instance on a host within
                        the same IP block.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="xref py py-class">DifferentHostFilter</literal> - allows the instance on a different host from a
                        set of instances.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="xref py py-class">SameHostFilter</literal> - puts the instance on the same host as another instance in
                        a set of instances.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="xref py py-class">RetryFilter</literal> - filters hosts that have been attempted for scheduling.
                        Only passes hosts that have not been previously attempted.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="xref py py-class">TrustedFilter</literal> (EXPERIMENTAL) - filters hosts based on their trust.  Only
                        passes hosts that meet the trust requirements specified in the instance
                        properties.</paragraph>
                    <warning>
                        <paragraph>TrustedFilter is deprecated for removal in the 17.0.0 Queens
                            release. There is no replacement planned for this filter. It has been
                            marked experimental since its inception. It is incomplete and not tested.</paragraph>
                    </warning>
                </list_item>
                <list_item>
                    <paragraph><literal classes="xref py py-class">TypeAffinityFilter</literal> - Only passes hosts that are not already running an
                        instance of the requested type.</paragraph>
                    <warning>
                        <paragraph>TypeAffinityFilter is deprecated for removal in the
                            17.0.0 Queens release. There is no replacement planned for this
                            filter. It is fundamentally flawed in that it relies on the
                            <literal>flavors.id</literal> primary key and if a flavor "changed", i.e. deleted
                            and re-created with new values, it will result in this filter
                            thinking it is a different flavor, thus breaking the usefulness of
                            this filter.</paragraph>
                    </warning>
                </list_item>
                <list_item>
                    <definition_list>
                        <definition_list_item>
                            <term><literal classes="xref py py-class">AggregateTypeAffinityFilter</literal> - limits instance_type by aggregate.</term>
                            <definition>
                                <paragraph>This filter passes hosts if no instance_type key is set or
                                    the instance_type aggregate metadata value contains the name of the
                                    instance_type requested. The value of the instance_type metadata entry is
                                    a string that may contain either a single instance_type name or a comma
                                    separated list of instance_type names. e.g. 'm1.nano' or "m1.nano,m1.small"</paragraph>
                            </definition>
                        </definition_list_item>
                    </definition_list>
                </list_item>
                <list_item>
                    <paragraph><literal classes="xref py py-class">ServerGroupAntiAffinityFilter</literal> - This filter implements anti-affinity for a
                        server group.  First you must create a server group with a policy of
                        'anti-affinity' via the server groups API.  Then, when you boot a new server,
                        provide a scheduler hint of 'group=&lt;uuid&gt;' where &lt;uuid&gt; is the UUID of the
                        server group you created.  This will result in the server getting added to the
                        group.  When the server gets scheduled, anti-affinity will be enforced among
                        all servers in that group.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="xref py py-class">ServerGroupAffinityFilter</literal> - This filter works the same way as
                        ServerGroupAntiAffinityFilter. The difference is that when you create the server
                        group, you should specify a policy of 'affinity'.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="xref py py-class">AggregateMultiTenancyIsolation</literal> - isolate tenants in specific aggregates.
                        To specify multiple tenants use a comma. Eg. "tenant1,tenant2"</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="xref py py-class">AggregateImagePropertiesIsolation</literal> - isolates hosts based on image
                        properties and aggregate metadata. Use a comma to specify multiple values for the
                        same property. The filter will then ensure at least one value matches.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="xref py py-class">MetricsFilter</literal> - filters hosts based on metrics weight_setting. Only hosts with
                        the available metrics are passed.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="xref py py-class">NUMATopologyFilter</literal> - filters hosts based on the NUMA topology requested by the
                        instance, if any.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>Now we can focus on these standard filter classes in some detail. We'll skip the
                simplest ones, such as <literal classes="xref py py-class">AllHostsFilter</literal>, <literal classes="xref py py-class">CoreFilter</literal> and <literal classes="xref py py-class">RamFilter</literal>,
                because their functionality is relatively simple and can be understood from the
                code. For example class <literal classes="xref py py-class">RamFilter</literal> has the next realization:</paragraph>
            <literal_block xml:space="preserve">class RamFilter(filters.BaseHostFilter):
    """Ram Filter with over subscription flag"""

    def host_passes(self, host_state, filter_properties):
        """Only return hosts with sufficient available RAM."""
        instance_type = filter_properties.get('instance_type')
        requested_ram = instance_type['memory_mb']
        free_ram_mb = host_state.free_ram_mb
        total_usable_ram_mb = host_state.total_usable_ram_mb
        used_ram_mb = total_usable_ram_mb - free_ram_mb
        return total_usable_ram_mb * FLAGS.ram_allocation_ratio  - used_ram_mb &gt;= requested_ram</literal_block>
            <paragraph>Here <literal>ram_allocation_ratio</literal> means the virtual RAM to physical RAM allocation
                ratio (it is <literal>1.5</literal> by default).</paragraph>
            <paragraph>The <literal classes="xref py py-class">AvailabilityZoneFilter</literal> looks at the availability zone of compute node
                and availability zone from the properties of the request. Each compute service
                has its own availability zone. So deployment engineers have an option to run
                scheduler with availability zones support and can configure availability zones
                on each compute host. This class's method <literal>host_passes</literal> returns <literal>True</literal> if
                availability zone mentioned in request is the same on the current compute host.</paragraph>
            <paragraph>The <literal classes="xref py py-class">ImagePropertiesFilter</literal> filters hosts based on the architecture,
                hypervisor type and virtual machine mode specified in the
                instance.  For example, an instance might require a host that supports the ARM
                architecture on a qemu compute host. The <literal classes="xref py py-class">ImagePropertiesFilter</literal> will only
                pass hosts that can satisfy this request. These instance
                properties are populated from properties defined on the instance's image.
                E.g. an image can be decorated with these properties using
                <literal>glance image-update img-uuid --property architecture=arm --property
hypervisor_type=qemu</literal>
                Only hosts that satisfy these requirements will pass the
                <literal classes="xref py py-class">ImagePropertiesFilter</literal>.</paragraph>
            <paragraph><literal classes="xref py py-class">ComputeCapabilitiesFilter</literal> checks if the host satisfies any <literal>extra_specs</literal>
                specified on the instance type.  The <literal>extra_specs</literal> can contain key/value pairs.
                The key for the filter is either non-scope format (i.e. no <literal>:</literal> contained), or
                scope format in capabilities scope (i.e. <literal>capabilities:xxx:yyy</literal>). One example
                of capabilities scope is <literal>capabilities:cpu_info:features</literal>, which will match
                host's cpu features capabilities. The <literal classes="xref py py-class">ComputeCapabilitiesFilter</literal> will only
                pass hosts whose capabilities satisfy the requested specifications.  All hosts
                are passed if no <literal>extra_specs</literal> are specified.</paragraph>
            <paragraph><literal classes="xref py py-class">ComputeFilter</literal> is quite simple and passes any host whose compute service is
                enabled and operational.</paragraph>
            <paragraph>Now we are going to <literal classes="xref py py-class">IsolatedHostsFilter</literal>. There can be some special hosts
                reserved for specific images. These hosts are called <strong>isolated</strong>. So the
                images to run on the isolated hosts are also called isolated. The filter
                checks if <literal>isolated_images</literal> flag named in instance specifications is the same
                as the host specified in <literal>isolated_hosts</literal>. Isolated hosts can run non-isolated
                images if the flag <literal>restrict_isolated_hosts_to_isolated_images</literal> is set to false.</paragraph>
            <paragraph><literal classes="xref py py-class">DifferentHostFilter</literal> - method <literal>host_passes</literal> returns <literal>True</literal> if the host to
                place an instance on is different from all the hosts used by a set of instances.</paragraph>
            <paragraph><literal classes="xref py py-class">SameHostFilter</literal> does the opposite to what <literal classes="xref py py-class">DifferentHostFilter</literal> does.
                <literal>host_passes</literal> returns <literal>True</literal> if the host we want to place an instance on is
                one of the hosts used by a set of instances.</paragraph>
            <paragraph><literal classes="xref py py-class">SimpleCIDRAffinityFilter</literal> looks at the subnet mask and investigates if
                the network address of the current host is in the same sub network as it was
                defined in the request.</paragraph>
            <paragraph><literal classes="xref py py-class">JsonFilter</literal> - this filter provides the opportunity to write complicated
                queries for the hosts capabilities filtering, based on simple JSON-like syntax.
                There can be used the following operations for the host states properties:
                <literal>=</literal>, <literal>&lt;</literal>, <literal>&gt;</literal>, <literal>in</literal>, <literal>&lt;=</literal>, <literal>&gt;=</literal>, that can be combined with the following
                logical operations: <literal>not</literal>, <literal>or</literal>, <literal>and</literal>. For example, the following query can be
                found in tests:</paragraph>
            <literal_block xml:space="preserve">['and',
    ['&gt;=', '$free_ram_mb', 1024],
    ['&gt;=', '$free_disk_mb', 200 * 1024]
]</literal_block>
            <paragraph>This query will filter all hosts with free RAM greater or equal than 1024 MB
                and at the same time with free disk space greater or equal than 200 GB.</paragraph>
            <paragraph>Many filters use data from <literal>scheduler_hints</literal>, that is defined in the moment of
                creation of the new server for the user. The only exception for this rule is
                <literal classes="xref py py-class">JsonFilter</literal>, that takes data from the schedulers <literal>HostState</literal> data structure
                directly. Variable naming, such as the <literal>$free_ram_mb</literal> example above, should
                be based on those attributes.</paragraph>
            <paragraph>The <literal classes="xref py py-class">RetryFilter</literal> filters hosts that have already been attempted for
                scheduling. It only passes hosts that have not been previously attempted. If a
                compute node is raising an exception when spawning an instance, then the
                compute manager will reschedule it by adding the failing host to a retry
                dictionary so that the RetryFilter will not accept it as a possible
                destination. That means that if all of your compute nodes are failing, then the
                RetryFilter will return 0 hosts and the scheduler will raise a NoValidHost
                exception even if the problem is related to 1:N compute nodes. If you see that
                case in the scheduler logs, then your problem is most likely related to a
                compute problem and you should check the compute logs.</paragraph>
            <paragraph>The <literal classes="xref py py-class">TrustedFilter</literal> filters hosts based on their trust.  Only passes hosts
                that match the trust requested in the <literal>extra_specs</literal> for the flavor. The key
                for this filter must be scope format as <literal>trust:trusted_host</literal>, where <literal>trust</literal>
                is the scope of the key and <literal>trusted_host</literal> is the actual key value.
                The value of this pair (<literal>trusted</literal>/<literal>untrusted</literal>) must match the
                integrity of a host (obtained from the Attestation service) before it is
                passed by the <literal classes="xref py py-class">TrustedFilter</literal>.</paragraph>
            <paragraph>The <literal classes="xref py py-class">NUMATopologyFilter</literal> considers the NUMA topology that was specified for the instance
                through the use of flavor extra_specs in combination with the image properties, as
                described in detail in the related nova-spec document:</paragraph>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph><reference refuri="http://git.openstack.org/cgit/openstack/nova-specs/tree/specs/juno/virt-driver-numa-placement.rst">http://git.openstack.org/cgit/openstack/nova-specs/tree/specs/juno/virt-driver-numa-placement.rst</reference></paragraph>
                </list_item>
            </bullet_list>
            <paragraph>and try to match it with the topology exposed by the host, accounting for the
                <literal>ram_allocation_ratio</literal> and <literal>cpu_allocation_ratio</literal> for over-subscription. The
                filtering is done in the following manner:</paragraph>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph>Filter will attempt to pack instance cells onto host cells.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>It will consider the standard over-subscription limits for each host NUMA cell,
                        and provide limits to the compute host accordingly (as mentioned above).</paragraph>
                </list_item>
                <list_item>
                    <paragraph>If instance has no topology defined, it will be considered for any host.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>If instance has a topology defined, it will be considered only for NUMA
                        capable hosts.</paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="configuring-filters" names="configuring\ filters">
            <title>Configuring Filters</title>
            <paragraph>To use filters you specify two settings:</paragraph>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph><literal>filter_scheduler.available_filters</literal> - Defines filter classes made
                        available to the scheduler. This setting can be used multiple times.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>filter_scheduler.enabled_filters</literal> - Of the available filters, defines
                        those that the scheduler uses by default.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>The default values for these settings in nova.conf are:</paragraph>
            <literal_block xml:space="preserve">--filter_scheduler.available_filters=nova.scheduler.filters.all_filters
--filter_scheduler.enabled_filters=RamFilter,ComputeFilter,AvailabilityZoneFilter,ComputeCapabilitiesFilter,ImagePropertiesFilter,ServerGroupAntiAffinityFilter,ServerGroupAffinityFilter</literal_block>
            <paragraph>With this configuration, all filters in <literal>nova.scheduler.filters</literal>
                would be available, and by default the <literal classes="xref py py-class">RamFilter</literal>, <literal classes="xref py py-class">ComputeFilter</literal>,
                <literal classes="xref py py-class">AvailabilityZoneFilter</literal>, <literal classes="xref py py-class">ComputeCapabilitiesFilter</literal>,
                <literal classes="xref py py-class">ImagePropertiesFilter</literal>, <literal classes="xref py py-class">ServerGroupAntiAffinityFilter</literal>,
                and <literal classes="xref py py-class">ServerGroupAffinityFilter</literal> would be used.</paragraph>
        </section>
        <section ids="writing-your-own-filter" names="writing\ your\ own\ filter">
            <title>Writing Your Own Filter</title>
            <paragraph>To create <strong>your own filter</strong> you must inherit from
                <literal classes="xref py py-class">BaseHostFilter</literal> and implement one method:
                <literal>host_passes</literal>. This method should return <literal>True</literal> if a host passes the filter. It
                takes <literal>host_state</literal> (describing the host) and <literal>filter_properties</literal> dictionary as the
                parameters.</paragraph>
            <paragraph>As an example, nova.conf could contain the following scheduler-related
                settings:</paragraph>
            <literal_block xml:space="preserve">--scheduler.driver=nova.scheduler.FilterScheduler
--filter_scheduler.available_filters=nova.scheduler.filters.all_filters
--filter_scheduler.available_filters=myfilter.MyFilter
--filter_scheduler.enabled_filters=RamFilter,ComputeFilter,MyFilter</literal_block>
            <note>
                <paragraph>When writing your own filter, be sure to add it to the list of available filters
                    and enable it in the default filters. The "all_filters" setting  only includes the
                    filters shipped with nova.</paragraph>
            </note>
            <paragraph>With these settings, nova will use the <literal>FilterScheduler</literal> for the scheduler
                driver. All of the standard nova filters and MyFilter are available to the
                FilterScheduler, but just the RamFilter, ComputeFilter, and MyFilter will be
                used on each request.</paragraph>
            <paragraph>Each filter selects hosts in a different way and has different costs. The order
                of <literal>filter_scheduler.enabled_filters</literal> affects scheduling performance. The
                general suggestion is to filter out invalid hosts as soon as possible to avoid
                unnecessary costs.  We can sort <literal>filter_scheduler.enabled_filters</literal> items by
                their costs in reverse order. For example, ComputeFilter is better before any
                resource calculating filters like RamFilter, CoreFilter.</paragraph>
            <paragraph>In medium/large environments having AvailabilityZoneFilter before any
                capability or resource calculating filters can be useful.</paragraph>
        </section>
        <section ids="weights" names="weights">
            <title>Weights</title>
            <paragraph>Filter Scheduler uses the so-called <strong>weights</strong> during its work. A weigher is a
                way to select the best suitable host from a group of valid hosts by giving
                weights to all the hosts in the list.</paragraph>
            <paragraph>In order to prioritize one weigher against another, all the weighers have to
                define a multiplier that will be applied before computing the weight for a node.
                All the weights are normalized beforehand so that the  multiplier can be applied
                easily. Therefore the final weight for the object will be:</paragraph>
            <literal_block xml:space="preserve">weight = w1_multiplier * norm(w1) + w2_multiplier * norm(w2) + ...</literal_block>
            <paragraph>A weigher should be a subclass of <literal>weights.BaseHostWeigher</literal> and they can implement
                both the <literal>weight_multiplier</literal> and <literal>_weight_object</literal> methods or just implement the
                <literal>weight_objects</literal> method. <literal>weight_objects</literal> method is overridden only if you need
                access to all objects in order to calculate weights, and it just return a list of weights,
                and not modify the weight of the object directly, since final weights are normalized
                and computed by <literal>weight.BaseWeightHandler</literal>.</paragraph>
            <paragraph>The Filter Scheduler weighs hosts based on the config option
                <title_reference>filter_scheduler.weight_classes</title_reference>, this defaults to
                <title_reference>nova.scheduler.weights.all_weighers</title_reference>, which selects the following weighers:</paragraph>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph><literal classes="xref py py-class">RAMWeigher</literal> Compute weight based on available RAM on the compute node.
                        Sort with the largest weight winning. If the multiplier is negative, the
                        host with least RAM available will win (useful for stacking hosts, instead
                        of spreading).</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="xref py py-class">DiskWeigher</literal> Hosts are weighted and sorted by free disk space with the largest
                        weight winning.  If the multiplier is negative, the host with less disk space available
                        will win (useful for stacking hosts, instead of spreading).</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="xref py py-class">MetricsWeigher</literal> This weigher can compute the weight based on the compute node
                        host's various metrics. The to-be weighed metrics and their weighing ratio
                        are specified in the configuration file as the followings:</paragraph>
                    <literal_block xml:space="preserve">metrics_weight_setting = name1=1.0, name2=-1.0</literal_block>
                </list_item>
                <list_item>
                    <paragraph><literal classes="xref py py-class">IoOpsWeigher</literal> The weigher can compute the weight based on the compute node
                        host's workload. The default is to preferably choose light workload compute
                        hosts. If the multiplier is positive, the weigher prefer choosing heavy
                        workload compute hosts, the weighing has the opposite effect of the default.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="xref py py-class">PCIWeigher</literal> Compute a weighting based on the number of PCI devices on the
                        host and the number of PCI devices requested by the instance. For example,
                        given three hosts - one with a single PCI device, one with many PCI devices,
                        and one with no PCI devices - nova should prioritise these differently based
                        on the demands of the instance. If the instance requests a single PCI device,
                        then the first of the hosts should be preferred. Similarly, if the instance
                        requests multiple PCI devices, then the second of these hosts would be
                        preferred. Finally, if the instance does not request a PCI device, then the
                        last of these hosts should be preferred.</paragraph>
                    <paragraph>For this to be of any value, at least one of the <literal classes="xref py py-class">PciPassthroughFilter</literal> or
                        <literal classes="xref py py-class">NUMATopologyFilter</literal> filters must be enabled.</paragraph>
                    <field_list>
                        <field>
                            <field_name>Configuration Option</field_name>
                            <field_body>
                                <paragraph><literal>[filter_scheduler] pci_weight_multiplier</literal>. Only
                                    positive values are allowed for the multiplier as a negative value would
                                    force non-PCI instances away from non-PCI hosts, thus, causing future
                                    scheduling issues.</paragraph>
                            </field_body>
                        </field>
                    </field_list>
                </list_item>
                <list_item>
                    <paragraph><literal classes="xref py py-class">ServerGroupSoftAffinityWeigher</literal> The weigher can compute the weight based
                        on the number of instances that run on the same server group. The largest
                        weight defines the preferred host for the new instance. For the multiplier
                        only a positive value is meaningful for the calculation as a negative value
                        would mean that the affinity weigher would prefer non collocating placement.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal classes="xref py py-class">ServerGroupSoftAntiAffinityWeigher</literal> The weigher can compute the weight based
                        on the number of instances that run on the same server group as a negative
                        value. The largest weight defines the preferred host for the new instance.
                        For the multiplier only a positive value is meaningful for the calculation as
                        a negative value would mean that the anti-affinity weigher would prefer
                        collocating placement.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>Filter Scheduler makes a local list of acceptable hosts by repeated filtering and
                weighing. Each time it chooses a host, it virtually consumes resources on it,
                so subsequent selections can adjust accordingly. It is useful if the customer
                asks for a large block of instances, because weight is computed for
                each instance requested.</paragraph>
            <image candidates="{'*': u'_static/images/filtering-workflow-2.png'}" uri="_static/images/filtering-workflow-2.png"></image>
            <paragraph>At the end Filter Scheduler sorts selected hosts by their weight and attempts
                to provision instances on the chosen hosts.</paragraph>
            <paragraph>P.S.: you can find more examples of using Filter Scheduler and standard filters
                in <literal classes="xref py py-mod">nova.tests.scheduler</literal>.</paragraph>
            <substitution_definition names="AllHostsFilter"><literal classes="xref py py-class">AllHostsFilter</literal></substitution_definition>
            <substitution_definition names="ImagePropertiesFilter"><literal classes="xref py py-class">ImagePropertiesFilter</literal></substitution_definition>
            <substitution_definition names="AvailabilityZoneFilter"><literal classes="xref py py-class">AvailabilityZoneFilter</literal></substitution_definition>
            <substitution_definition names="BaseHostFilter"><literal classes="xref py py-class">BaseHostFilter</literal></substitution_definition>
            <substitution_definition names="ComputeCapabilitiesFilter"><literal classes="xref py py-class">ComputeCapabilitiesFilter</literal></substitution_definition>
            <substitution_definition names="ComputeFilter"><literal classes="xref py py-class">ComputeFilter</literal></substitution_definition>
            <substitution_definition names="CoreFilter"><literal classes="xref py py-class">CoreFilter</literal></substitution_definition>
            <substitution_definition names="AggregateCoreFilter"><literal classes="xref py py-class">AggregateCoreFilter</literal></substitution_definition>
            <substitution_definition names="IsolatedHostsFilter"><literal classes="xref py py-class">IsolatedHostsFilter</literal></substitution_definition>
            <substitution_definition names="JsonFilter"><literal classes="xref py py-class">JsonFilter</literal></substitution_definition>
            <substitution_definition names="RamFilter"><literal classes="xref py py-class">RamFilter</literal></substitution_definition>
            <substitution_definition names="AggregateRamFilter"><literal classes="xref py py-class">AggregateRamFilter</literal></substitution_definition>
            <substitution_definition names="DiskFilter"><literal classes="xref py py-class">DiskFilter</literal></substitution_definition>
            <substitution_definition names="AggregateDiskFilter"><literal classes="xref py py-class">AggregateDiskFilter</literal></substitution_definition>
            <substitution_definition names="NumInstancesFilter"><literal classes="xref py py-class">NumInstancesFilter</literal></substitution_definition>
            <substitution_definition names="AggregateNumInstancesFilter"><literal classes="xref py py-class">AggregateNumInstancesFilter</literal></substitution_definition>
            <substitution_definition names="IoOpsFilter"><literal classes="xref py py-class">IoOpsFilter</literal></substitution_definition>
            <substitution_definition names="AggregateIoOpsFilter"><literal classes="xref py py-class">AggregateIoOpsFilter</literal></substitution_definition>
            <substitution_definition names="PciPassthroughFilter"><literal classes="xref py py-class">PciPassthroughFilter</literal></substitution_definition>
            <substitution_definition names="SimpleCIDRAffinityFilter"><literal classes="xref py py-class">SimpleCIDRAffinityFilter</literal></substitution_definition>
            <substitution_definition names="DifferentHostFilter"><literal classes="xref py py-class">DifferentHostFilter</literal></substitution_definition>
            <substitution_definition names="SameHostFilter"><literal classes="xref py py-class">SameHostFilter</literal></substitution_definition>
            <substitution_definition names="RetryFilter"><literal classes="xref py py-class">RetryFilter</literal></substitution_definition>
            <substitution_definition names="TrustedFilter"><literal classes="xref py py-class">TrustedFilter</literal></substitution_definition>
            <substitution_definition names="TypeAffinityFilter"><literal classes="xref py py-class">TypeAffinityFilter</literal></substitution_definition>
            <substitution_definition names="AggregateTypeAffinityFilter"><literal classes="xref py py-class">AggregateTypeAffinityFilter</literal></substitution_definition>
            <substitution_definition names="ServerGroupAntiAffinityFilter"><literal classes="xref py py-class">ServerGroupAntiAffinityFilter</literal></substitution_definition>
            <substitution_definition names="ServerGroupAffinityFilter"><literal classes="xref py py-class">ServerGroupAffinityFilter</literal></substitution_definition>
            <substitution_definition names="AggregateInstanceExtraSpecsFilter"><literal classes="xref py py-class">AggregateInstanceExtraSpecsFilter</literal></substitution_definition>
            <substitution_definition names="AggregateMultiTenancyIsolation"><literal classes="xref py py-class">AggregateMultiTenancyIsolation</literal></substitution_definition>
            <substitution_definition names="NUMATopologyFilter"><literal classes="xref py py-class">NUMATopologyFilter</literal></substitution_definition>
            <substitution_definition names="RAMWeigher"><literal classes="xref py py-class">RAMWeigher</literal></substitution_definition>
            <substitution_definition names="AggregateImagePropertiesIsolation"><literal classes="xref py py-class">AggregateImagePropertiesIsolation</literal></substitution_definition>
            <substitution_definition names="MetricsFilter"><literal classes="xref py py-class">MetricsFilter</literal></substitution_definition>
            <substitution_definition names="MetricsWeigher"><literal classes="xref py py-class">MetricsWeigher</literal></substitution_definition>
            <substitution_definition names="IoOpsWeigher"><literal classes="xref py py-class">IoOpsWeigher</literal></substitution_definition>
            <substitution_definition names="PCIWeigher"><literal classes="xref py py-class">PCIWeigher</literal></substitution_definition>
            <substitution_definition names="ServerGroupSoftAffinityWeigher"><literal classes="xref py py-class">ServerGroupSoftAffinityWeigher</literal></substitution_definition>
            <substitution_definition names="ServerGroupSoftAntiAffinityWeigher"><literal classes="xref py py-class">ServerGroupSoftAntiAffinityWeigher</literal></substitution_definition>
            <substitution_definition names="DiskWeigher"><literal classes="xref py py-class">DiskWeigher</literal></substitution_definition>
        </section>
    </section>
</document>
