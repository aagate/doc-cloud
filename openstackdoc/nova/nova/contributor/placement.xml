<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document source="/home/fbaumanis/openstack/soc8_test/openstack_repo/nova/doc/source/contributor/placement.rst">
    <comment xml:space="preserve">Licensed under the Apache License, Version 2.0 (the "License"); you may
not use this file except in compliance with the License. You may obtain
a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations
under the License.</comment>
    <section ids="placement-api-developer-notes" names="placement\ api\ developer\ notes">
        <title>Placement API Developer Notes</title>
        <section ids="overview" names="overview">
            <title>Overview</title>
            <paragraph>The Nova project introduced the <reference internal="True" refuri="../user/placement"><inline classes="doc">placement service</inline></reference> as
                part of the Newton release. The service provides an HTTP API to manage
                inventories of different classes of resources, such as disk or virtual cpus,
                made available by entities called resource providers. Information provided
                through the placement API is intended to enable more effective accounting of
                resources in an OpenStack deployment and better scheduling of various entities
                in the cloud.</paragraph>
            <paragraph>The document serves to explain the architecture of the system and to provide
                some guidance on how to maintain and extend the code. For more detail on why
                the system was created and how it does its job see <reference internal="True" refuri="../user/placement"><inline classes="doc">Placement API</inline></reference>.</paragraph>
        </section>
        <section ids="big-picture" names="big\ picture">
            <title>Big Picture</title>
            <paragraph>The placement service is straightforward: It is a <reference name="WSGI" refuri="https://www.python.org/dev/peps/pep-3333/">WSGI</reference> application that
                sends and receives JSON, using an RDBMS (usually MySQL) for persistence.
                As state is managed solely in the DB, scaling the placement service is done by
                increasing the number of WSGI application instances and scaling the RDBMS using
                traditional database scaling techniques.</paragraph>
            <paragraph>For sake of consistency and because there was initially intent to make the
                entities in the placement service available over RPC, <reference name="versioned objects" refuri="http://docs.openstack.org/developer/oslo.versionedobjects/">versioned objects</reference> are
                used to provide the interface between the HTTP application layer and the
                SQLAlchemy-driven persistence layer. Even without RPC, these objects provide
                useful structuring and separation of the code.</paragraph>
            <paragraph>Though the placement service doesn't aspire to be a <title_reference>microservice</title_reference> it does
                aspire to continue to be small and minimally complex. This means a relatively
                small amount of middleware that is not configurable, and a limited number of
                exposed resources where any given resource is represented by one (and only
                one) URL that expresses a noun that is a member of the system. Adding
                additional resources should be considered a significant change requiring robust
                review from many stakeholders.</paragraph>
            <paragraph>The set of HTTP resources represents a concise and constrained grammar for
                expressing the management of resource providers, inventories, resource classes
                and allocations. If a solution is initially designed to need more resources or
                a more complex grammar that may be a sign that we need to give our goals
                greater scrutiny. Is there a way to do what we want with what we have already?
                Can some other service help? Is a new collaborating service required?</paragraph>
        </section>
        <section ids="minimal-framework" names="minimal\ framework">
            <title>Minimal Framework</title>
            <paragraph>The API is set up to use a minimal framework that tries to keep the structure
                of the application as discoverable as possible and keeps the HTTP interaction
                near the surface. The goal of this is to make things easy to trace when
                debugging or adding functionality.</paragraph>
            <paragraph>Functionality which is required for every request is handled in raw WSGI
                middleware that is composed in the <title_reference>nova.api.openstack.placement.deploy</title_reference>
                module. Dispatch or routing is handled declaratively via the
                <literal>ROUTE_DECLARATIONS</literal> map defined in the
                <title_reference>nova.api.openstack.placement.handler</title_reference> module.</paragraph>
            <paragraph>Mapping is by URL plus request method. The destination is a complete WSGI
                application, using a subclass of the <reference name="wsgify" refuri="http://docs.webob.org/en/latest/api/dec.html">wsgify</reference>  method from <reference name="WebOb" refuri="http://docs.webob.org/en/latest/">WebOb</reference> to provide
                a <reference name="Request" refuri="http://docs.webob.org/en/latest/reference.html#request">Request</reference> object that provides convenience methods for accessing request
                headers, bodies, and query parameters and for generating responses. In the
                placement API these mini-applications are called <title_reference>handlers</title_reference>. The <title_reference>wsgify</title_reference>
                subclass is provided in <title_reference>nova.api.openstack.placement.wsgi_wrapper</title_reference> as
                <title_reference>PlacementWsgify</title_reference>. It is used to make sure that JSON formatted error responses
                are structured according to the API-WG <reference name="errors" refuri="http://specs.openstack.org/openstack/api-wg/guidelines/errors.html">errors</reference> guideline.</paragraph>
            <paragraph>This division between middleware, dispatch and handlers is supposed to
                provide clues on where a particular behavior or functionality should be
                implemented. Like most such systems, this doesn't always work but is a useful
                tool.</paragraph>
        </section>
        <section ids="gotchas" names="gotchas">
            <title>Gotchas</title>
            <paragraph>This section tries to shed some light on some of the differences between the
                placement API and some of the nova APIs or on situations which may be
                surprising or unexpected.</paragraph>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph>The placement API is somewhat more strict about <title_reference>Content-Type</title_reference> and <title_reference>Accept</title_reference>
                        headers in an effort to follow the HTTP RFCs.</paragraph>
                    <paragraph>If a user-agent sends some JSON in a <title_reference>PUT</title_reference> or <title_reference>POST</title_reference> request without a
                        <title_reference>Content-Type</title_reference> of <title_reference>application/json</title_reference> the request will result in an error.</paragraph>
                    <paragraph>If a <title_reference>GET</title_reference> request is made without an <title_reference>Accept</title_reference> header, the response will
                        default to being <title_reference>application/json</title_reference>.</paragraph>
                    <paragraph>If a request is made with an explicit <title_reference>Accept</title_reference> header that does not include
                        <title_reference>application/json</title_reference> then there will be an error and the error will attempt to
                        be in the requested format (for example, <title_reference>text/plain</title_reference>).</paragraph>
                </list_item>
                <list_item>
                    <paragraph>If a URL exists, but a request is made using a method that that URL does not
                        support, the API will respond with a <title_reference>405</title_reference> error. Sometimes in the nova APIs
                        this can be a <title_reference>404</title_reference> (which is wrong, but understandable given the constraints
                        of the code).</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Because each handler is individually wrapped by the <title_reference>PlacementWsgify</title_reference>
                        decorator any exception that is a subclass of <title_reference>webob.exc.WSGIHTTPException</title_reference>
                        that is raised from within the handler, such as <title_reference>webob.exc.HTTPBadRequest</title_reference>,
                        will be caught by WebOb and turned into a valid <reference name="Response" refuri="http://docs.webob.org/en/latest/#response">Response</reference> containing
                        headers and body set by WebOb based on the information given when the
                        exception was raised. It will not be seen as an exception by any of the
                        middleware in the placement stack.</paragraph>
                    <paragraph>In general this is a good thing, but it can lead to some confusion if, for
                        example, you are trying to add some middleware that operates on exceptions.</paragraph>
                    <paragraph>Other exceptions that are not from <reference name="WebOb" refuri="http://docs.webob.org/en/latest/">WebOb</reference> will raise outside the handlers
                        where they will either be caught in the <title_reference>__call__</title_reference> method of the
                        <title_reference>PlacementHandler</title_reference> app that is responsible for dispatch, or by the
                        <title_reference>FaultWrap</title_reference> middleware.</paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section dupnames="microversions" ids="microversions">
            <title>Microversions</title>
            <paragraph>The placement API makes use of <reference name="microversions" refuri="http://specs.openstack.org/openstack/api-wg/guidelines/microversion_specification.html">microversions</reference> to allow the release of new
                features on an opt in basis. See <reference internal="True" refuri="../user/placement"><inline classes="doc">Placement API</inline></reference> for an up to date
                history of the available microversions.</paragraph>
            <paragraph>The rules around when a microversion is needed are the same as for the
                <reference internal="True" refuri="microversions"><inline classes="doc">compute API</inline></reference>. When adding a new microversion
                there are a few bits of required housekeeping that must be done in the code:</paragraph>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph>Update the <literal>VERSIONS</literal> list in
                        <title_reference>nova.api.openstack.placement.microversion</title_reference> to indicate the new
                        microversion and give a very brief summary of the added feature.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Update <title_reference>nova/api/openstack/placement/rest_api_version_history.rst</title_reference>
                        to add a more detailed section describing the new microversion.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Add a <reference name="release note" refuri="http://docs.openstack.org/developer/reno/usage.html">release note</reference> announcing the new or changed feature and
                        the microversion.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>If the <literal>version_handler</literal> decorator (see below) has been used,
                        increment <literal>TOTAL_VERSIONED_METHODS</literal> in
                        <title_reference>nova/tests/unit/api/openstack/placement/test_microversion.py</title_reference>.
                        This provides a confirmatory check just to make sure you're paying
                        attention and as a helpful reminder to do the other things in this
                        list.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>In the placement API, microversions only use the modern form of the
                version header:</paragraph>
            <literal_block xml:space="preserve">OpenStack-API-Version: placement 1.2</literal_block>
            <paragraph>If a valid microversion is present in a request it will be placed,
                as a <literal>Version</literal> object, into the WSGI environment with the
                <literal>placement.microversion</literal> key. Often, accessing this in handler
                code directly (to control branching) is the most explicit and
                granular way to have different behavior per microversion. A
                <literal>Version</literal> instance can be treated as a tuple of two ints and
                compared as such or there is a <literal>matches</literal> method.</paragraph>
            <paragraph>In other cases there are some helper methods in the microversion
                package:</paragraph>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph>The <literal>raise_http_status_code_if_not_version</literal> utility will raise a
                        http status code if the requested microversion is not within a
                        described version window.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The <literal>version_handler</literal> decorator makes it possible to have
                        multiple different handler methods of the same (fully-qualified by
                        package) name, each available for a different microversion window.
                        If a request wants a microversion that's not available, a 404
                        response is returned. There is a unit test in place which will
                        fail if there are version intersections.</paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="adding-a-new-handler" names="adding\ a\ new\ handler">
            <title>Adding a New Handler</title>
            <paragraph>Adding a new URL or a new method (e.g, <literal>PATCH</literal>) to an existing URL
                requires adding a new handler function. In either case a new microversion and
                release note is required. When adding an entirely new route a request for a
                lower microversion should return a <literal>404</literal>. When adding a new method to an
                existing URL a request for a lower microversion should return a <literal>405</literal>.</paragraph>
            <paragraph>In either case, the <literal>ROUTE_DECLARATIONS</literal> dictionary in the
                <title_reference>nova.api.openstack.placement.handler</title_reference> module should be updated to point to a
                function within a module that contains handlers for the type of entity
                identified by the URL. Collection and individual entity handlers of the same
                type should be in the same module.</paragraph>
            <paragraph>As mentioned above, the handler function should be decorated with
                <literal>@wsgi_wrapper.PlacementWsgify</literal>, take a single argument <literal>req</literal> which is a
                WebOb <reference name="Request" refuri="http://docs.webob.org/en/latest/reference.html#request">Request</reference> object, and return a WebOb <reference name="Response" refuri="http://docs.webob.org/en/latest/#response">Response</reference>.</paragraph>
            <paragraph>For <literal>PUT</literal> and <literal>POST</literal> methods, request bodies are expected to be JSON
                based on a content-type of <literal>application/json</literal>. This may be enforced by using
                a decorator: <literal>@util.require_content('application/json')</literal>. If the body is not
                <title_reference>JSON</title_reference>, a <literal>415</literal> response status is returned.</paragraph>
            <paragraph>Response bodies are usually <title_reference>JSON</title_reference>. A handler can check the <title_reference>Accept</title_reference> header
                provided in a request using another decorator:
                <literal>@util.check_accept('application/json')</literal>. If the header does not allow
                <title_reference>JSON</title_reference>, a <literal>406</literal> response status is returned.</paragraph>
            <paragraph><title_reference>JSON</title_reference> sent in a request should be validated against a JSON Schema. A
                <literal>util.extract_json</literal> method is available. This takes a request body and a
                schema. If multiple schema are used for different microversions of the same
                request, the caller is responsible for selecting the right one before calling
                <literal>extract_json</literal>.</paragraph>
            <paragraph>When a handler needs to read or write the data store it should use methods on
                the objects found in the <title_reference>nova.objects.resource_provider</title_reference> package. Doing so
                requires a context which is provided to the handler method via the WSGI
                environment. It can be retrieved as follows:</paragraph>
            <literal_block xml:space="preserve">context = req.environ['placement.context']</literal_block>
            <note>
                <paragraph>If your change requires new methods or new objects in the
                    <title_reference>resource_provider</title_reference> package, after you've made sure that you really
                    do need those new methods or objects (you may not!) make those
                    changes in a patch that is separate from and prior to the HTTP API
                    change.</paragraph>
            </note>
            <paragraph>Testing of handler code is described in the next section.</paragraph>
        </section>
        <section ids="testing" names="testing">
            <title>Testing</title>
            <paragraph>Most of the handler code in the placement API is tested using <reference name="gabbi" refuri="https://gabbi.readthedocs.io/">gabbi</reference>. Some
                utility code is tested with unit tests found in
                <title_reference>nova/tests/unit/api/openstack/placement/</title_reference>. The back-end objects are tested
                with a combination of unit and functional tests found in
                <title_reference>nova/tests/unit/objects/test_resource_provider.py</title_reference> and
                <title_reference>nova/tests/functional/db</title_reference>. Adding unit and non-gabbi functional tests is done
                in the same way as other aspects of nova.</paragraph>
            <section ids="using-gabbi" names="using\ gabbi">
                <title>Using Gabbi</title>
                <paragraph>Gabbi was developed in the <reference name="telemetry" refuri="http://specs.openstack.org/openstack/telemetry-specs/specs/kilo/declarative-http-tests.html">telemetry</reference> project to provide a declarative way to
                    test HTTP APIs that preserves visibility of both the request and response of
                    the HTTP interaction. Tests are written in YAML files where each file is an
                    ordered suite of tests. Fixtures (such as a database) are set up and torn down
                    at the beginning and end of each file, not each test. JSON response bodies can
                    be evaluated with <reference name="JSONPath" refuri="http://goessner.net/articles/JsonPath/">JSONPath</reference>. The placement WSGI
                    application is run via <reference name="wsgi-intercept" refuri="http://wsgi-intercept.readthedocs.io/">wsgi-intercept</reference>, meaning that real HTTP requests are
                    being made over a file handle that appears to Python to be a socket.</paragraph>
                <paragraph>In the placement API the YAML files (aka "gabbits") can be found in
                    <title_reference>nova/tests/functional/api/openstack/placement/gabbits</title_reference>. Fixture definitions are
                    in <title_reference>fixtures.py</title_reference> in the parent directory. Tests are currently grouped by handlers
                    (e.g., <title_reference>resource-provider.yaml</title_reference> and <title_reference>inventory.yaml</title_reference>). This is not a
                    requirement and as we increase the number of tests it makes sense to have more
                    YAML files with fewer tests, divided up by the arc of API interaction that they
                    test.</paragraph>
                <paragraph>The gabbi tests are integrated into the functional tox target, loaded via
                    <title_reference>nova/tests/functional/api/openstack/placement/test_placement_api.py</title_reference>. If you
                    want to run just the gabbi tests one way to do so is:</paragraph>
                <literal_block xml:space="preserve">tox -efunctional test_placement_api</literal_block>
                <paragraph>If you want to run just one yaml file (in this example <title_reference>inventory.yaml</title_reference>):</paragraph>
                <literal_block xml:space="preserve">tox -efunctional placement_api.inventory</literal_block>
                <paragraph>It is also possible to run just one test from within one file. When you do this
                    every test prior to the one you asked for will also be run. This is because
                    the YAML represents a sequence of dependent requests. Select the test by using
                    the name in the yaml file, replacing space with <literal>_</literal>:</paragraph>
                <literal_block xml:space="preserve">tox -efunctional placement_api.inventory_post_new_ipv4_address_inventory</literal_block>
                <note>
                    <paragraph><title_reference>.testr.conf</title_reference> in the nova repository is configured such that each
                        gabbi YAML is considered a group. Thus, all tests in the file will
                        be run in the same process when running testr concurrently (the
                        default).</paragraph>
                </note>
            </section>
            <section ids="writing-more-gabbi-tests" names="writing\ more\ gabbi\ tests">
                <title>Writing More Gabbi Tests</title>
                <paragraph>The docs for <reference name="gabbi" refuri="https://gabbi.readthedocs.io/">gabbi</reference> try to be complete and explain the <reference name="syntax" refuri="https://gabbi.readthedocs.io/en/latest/format.html">syntax</reference> in some
                    depth. Where something is missing or confusing, please log a <reference name="bug" refuri="https://github.com/cdent/gabbi/issues">bug</reference>.</paragraph>
                <paragraph>While it is possible to test all aspects of a response (all the response
                    headers, the status code, every attribute in a JSON structure) in one single
                    test, doing so will likely make the test harder to read and will certainly make
                    debugging more challenging. If there are multiple things that need to be
                    asserted, making multiple requests is reasonable. Since database set up is only
                    happening once per file (instead of once per test) and since there's no TCP
                    overhead, the tests run quickly.</paragraph>
                <paragraph>While <reference name="fixtures" refuri="http://gabbi.readthedocs.io/en/latest/fixtures.html">fixtures</reference> can be used to establish entities that are required for
                    tests, creating those entities via the HTTP API results in tests which are more
                    descriptive. For example the <title_reference>inventory.yaml</title_reference> file creates the resource
                    provider to which it will then add inventory. This makes it easy to explore a
                    sequence of interactions and a variety of responses with the tests:</paragraph>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>create a resource provider</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>confirm it has empty inventory</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>add inventory to the resource provider (in a few different ways)</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>confirm the resource provider now has inventory</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>modify the inventory</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>delete the inventory</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>confirm the resource provider now has empty inventory</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>Nothing special is required to add a new set of tests: create a YAML file with
                    a unique name in the same directory as the others. The other files can provide
                    examples. Gabbi can provide a useful way of doing test driven development of a
                    new handler: create a YAML file that describes the desired URLs and behavior
                    and write the code to make it pass.</paragraph>
                <paragraph>It's also possible to use gabbi against a running placement service, for
                    example in devstack. See <reference name="gabbi-run" refuri="http://gabbi.readthedocs.io/en/latest/runner.html">gabbi-run</reference> to get started.</paragraph>
            </section>
        </section>
        <section ids="futures" names="futures">
            <title>Futures</title>
            <paragraph>Since before it was created there has been a long term goal for the placement
                service to be extracted to its own repository and operate as its own
                independent service. There are many reasons for this, but two main ones are:</paragraph>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph>Multiple projects, not just nova, will eventually need to manage resource
                        providers using the placement API.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>A separate service helps to maintain and preserve a strong contract between
                        the placement service and the consumers of the service.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>To lessen the pain of the eventual extraction of placement the service has been
                developed in a way to limit dependency on the rest of the nova codebase and be
                self-contained:</paragraph>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph>Most code is in <title_reference>nova/api/openstack/placement</title_reference> except for oslo versioned
                        object code in <title_reference>nova/objects/resource_provider.py</title_reference>.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Database query code is kept within the objects.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The methods on the objects are not remotable, as the only intended caller is
                        the placement API code.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>There are some exceptions to the self-contained rule (which will have to be
                addressed if the extraction ever happens):</paragraph>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph>Exceptions unique to the placement API are still within the <title_reference>nova.exceptions</title_reference>
                        package.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Code related to a resource class cache is within the <title_reference>nova.db</title_reference> package.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Database models, migrations and tables use the nova api database.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The nova <title_reference>FaultWrapper</title_reference> middleware is being used.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><title_reference>nova.i18n</title_reference> package provides the <literal>_</literal> and related functions.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><title_reference>nova.conf</title_reference> is used for configuration.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Unit and functional tests depend on fixtures and other functionality in base
                        classes provided by nova.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>When creating new code for the placement service, please be aware of the plan
                for an eventual extraction and avoid creating unnecessary interdependencies.</paragraph>
            <target ids="wsgi" names="wsgi" refuri="https://www.python.org/dev/peps/pep-3333/"></target>
            <target ids="versioned-objects" names="versioned\ objects" refuri="http://docs.openstack.org/developer/oslo.versionedobjects/"></target>
            <target ids="wsgify" names="wsgify" refuri="http://docs.webob.org/en/latest/api/dec.html"></target>
            <target ids="webob" names="webob" refuri="http://docs.webob.org/en/latest/"></target>
            <target ids="request" names="request" refuri="http://docs.webob.org/en/latest/reference.html#request"></target>
            <target ids="response" names="response" refuri="http://docs.webob.org/en/latest/#response"></target>
            <target ids="id1" names="microversions" refuri="http://specs.openstack.org/openstack/api-wg/guidelines/microversion_specification.html"></target>
            <target ids="release-note" names="release\ note" refuri="http://docs.openstack.org/developer/reno/usage.html"></target>
            <target ids="gabbi" names="gabbi" refuri="https://gabbi.readthedocs.io/"></target>
            <target ids="telemetry" names="telemetry" refuri="http://specs.openstack.org/openstack/telemetry-specs/specs/kilo/declarative-http-tests.html"></target>
            <target ids="wsgi-intercept" names="wsgi-intercept" refuri="http://wsgi-intercept.readthedocs.io/"></target>
            <target ids="syntax" names="syntax" refuri="https://gabbi.readthedocs.io/en/latest/format.html"></target>
            <target ids="bug" names="bug" refuri="https://github.com/cdent/gabbi/issues"></target>
            <target ids="fixtures" names="fixtures" refuri="http://gabbi.readthedocs.io/en/latest/fixtures.html"></target>
            <target ids="jsonpath" names="jsonpath" refuri="http://goessner.net/articles/JsonPath/"></target>
            <target ids="gabbi-run" names="gabbi-run" refuri="http://gabbi.readthedocs.io/en/latest/runner.html"></target>
            <target ids="errors" names="errors" refuri="http://specs.openstack.org/openstack/api-wg/guidelines/errors.html"></target>
        </section>
    </section>
</document>
