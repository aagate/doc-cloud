<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document source="/home/fbaumanis/openstack/soc8_test/openstack_repo/nova/doc/source/contributor/microversions.rst">
    <section ids="api-microversions" names="api\ microversions">
        <title>API Microversions</title>
        <section ids="background" names="background">
            <title>Background</title>
            <paragraph>Nova uses a framework we call 'API Microversions' for allowing changes
                to the API while preserving backward compatibility. The basic idea is
                that a user has to explicitly ask for their request to be treated with
                a particular version of the API. So breaking changes can be added to
                the API without breaking users who don't specifically ask for it. This
                is done with an HTTP header <literal>OpenStack-API-Version</literal> which has as its
                value a string containing the name of the service, <literal>compute</literal>, and a
                monotonically increasing semantic version number starting from <literal>2.1</literal>.
                The full form of the header takes the form:</paragraph>
            <literal_block xml:space="preserve">OpenStack-API-Version: compute 2.1</literal_block>
            <paragraph>If a user makes a request without specifying a version, they will get
                the <literal>DEFAULT_API_VERSION</literal> as defined in
                <literal>nova/api/openstack/wsgi.py</literal>.  This value is currently <literal>2.1</literal> and
                is expected to remain so for quite a long time.</paragraph>
            <paragraph>There is a special value <literal>latest</literal> which can be specified, which will
                allow a client to always receive the most recent version of API
                responses from the server.</paragraph>
            <warning>
                <paragraph>The <literal>latest</literal> value is mostly meant for integration testing and
                    would be dangerous to rely on in client code since Nova microversions are not
                    following semver and therefore backward compatibility is not guaranteed.
                    Clients, like python-novaclient, should always require a specific
                    microversion but limit what is acceptable to the version range that it
                    understands at the time.</paragraph>
            </warning>
            <warning>
                <paragraph>To maintain compatibility, an earlier form of the microversion
                    header is acceptable. It takes the form:</paragraph>
                <literal_block xml:space="preserve">X-OpenStack-Nova-API-Version: 2.1</literal_block>
                <paragraph>This form will continue to be supported until the <literal>DEFAULT_API_VERSION</literal>
                    is raised to version <literal>2.27</literal> or higher.</paragraph>
                <paragraph>Clients accessing deployments of the Nova API which are not yet
                    providing microversion <literal>2.27</literal> must use the older form.</paragraph>
            </warning>
            <paragraph>For full details please read the <reference name="Kilo spec for microversions" refuri="http://git.openstack.org/cgit/openstack/nova-specs/tree/specs/kilo/implemented/api-microversions.rst">Kilo spec for microversions</reference><target ids="kilo-spec-for-microversions" names="kilo\ spec\ for\ microversions" refuri="http://git.openstack.org/cgit/openstack/nova-specs/tree/specs/kilo/implemented/api-microversions.rst"></target>
                and <reference name="Microversion Specification" refuri="http://specs.openstack.org/openstack/api-wg/guidelines/microversion_specification.html">Microversion Specification</reference><target ids="microversion-specification" names="microversion\ specification" refuri="http://specs.openstack.org/openstack/api-wg/guidelines/microversion_specification.html"></target>.</paragraph>
        </section>
        <section ids="when-do-i-need-a-new-microversion" names="when\ do\ i\ need\ a\ new\ microversion?">
            <title>When do I need a new Microversion?</title>
            <paragraph>A microversion is needed when the contract to the user is
                changed. The user contract covers many kinds of information such as:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>the Request</paragraph>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph>the list of resource urls which exist on the server</paragraph>
                            <paragraph>Example: adding a new servers/{ID}/foo which didn't exist in a
                                previous version of the code</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>the list of query parameters that are valid on urls</paragraph>
                            <paragraph>Example: adding a new parameter <literal>is_yellow</literal> servers/{ID}?is_yellow=True</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>the list of query parameter values for non free form fields</paragraph>
                            <paragraph>Example: parameter filter_by takes a small set of constants/enums "A",
                                "B", "C". Adding support for new enum "D".</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>new headers accepted on a request</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>the list of attributes and data structures accepted.</paragraph>
                            <paragraph>Example: adding a new attribute 'locked': True/False to the request body</paragraph>
                            <paragraph>However, the attribute <literal>os.scheduler_hints</literal> of the "create a server" API
                                is an exception to this. A new scheduler which adds a new attribute
                                to <literal>os:scheduler_hints</literal> doesn't require a new microversion, because
                                available schedulers depend on cloud environments, and we accept customized
                                schedulers as a rule.</paragraph>
                        </list_item>
                    </bullet_list>
                </list_item>
                <list_item>
                    <paragraph>the Response</paragraph>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph>the list of attributes and data structures returned</paragraph>
                            <paragraph>Example: adding a new attribute 'locked': True/False to the output
                                of servers/{ID}</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>the allowed values of non free form fields</paragraph>
                            <paragraph>Example: adding a new allowed <literal>status</literal> to servers/{ID}</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>the list of status codes allowed for a particular request</paragraph>
                            <paragraph>Example: an API previously could return 200, 400, 403, 404 and the
                                change would make the API now also be allowed to return 409.</paragraph>
                            <paragraph>See <footnote_reference auto="1" ids="id1" refid="f2">2</footnote_reference> for the 400, 403, 404 and 415 cases.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>changing a status code on a particular response</paragraph>
                            <paragraph>Example: changing the return code of an API from 501 to 400.</paragraph>
                            <note>
                                <paragraph>Fixing a bug so that a 400+ code is returned rather than a 500 or
                                    503 does not require a microversion change. It's assumed that clients are
                                    not expected to handle a 500 or 503 response and therefore should not
                                    need to opt-in to microversion changes that fixes a 500 or 503 response
                                    from happening.
                                    According to the OpenStack API Working Group, a
                                    <strong>500 Internal Server Error</strong> should <strong>not</strong> be returned to the user for
                                    failures due to user error that can be fixed by changing the request on
                                    the client side. See <footnote_reference auto="1" ids="id2" refid="f1">1</footnote_reference>.</paragraph>
                            </note>
                        </list_item>
                        <list_item>
                            <paragraph>new headers returned on a response</paragraph>
                        </list_item>
                    </bullet_list>
                </list_item>
            </bullet_list>
            <paragraph>The following flow chart attempts to walk through the process of "do
                we need a microversion".</paragraph>
            <graphviz code="digraph states {&#10;&#10; label=&quot;Do I need a microversion?&quot;&#10;&#10; silent_fail[shape=&quot;diamond&quot;, style=&quot;&quot;, group=g1, label=&quot;Did we silently&#10;fail to do what is asked?&quot;];&#10; ret_500[shape=&quot;diamond&quot;, style=&quot;&quot;, group=g1, label=&quot;Did we return a 500&#10;before?&quot;];&#10; new_error[shape=&quot;diamond&quot;, style=&quot;&quot;, group=g1, label=&quot;Are we changing what&#10; status code is returned?&quot;];&#10; new_attr[shape=&quot;diamond&quot;, style=&quot;&quot;, group=g1, label=&quot;Did we add or remove an&#10; attribute to a payload?&quot;];&#10; new_param[shape=&quot;diamond&quot;, style=&quot;&quot;, group=g1, label=&quot;Did we add or remove&#10; an accepted query string parameter or value?&quot;];&#10; new_resource[shape=&quot;diamond&quot;, style=&quot;&quot;, group=g1, label=&quot;Did we add or remove a&#10;resource url?&quot;];&#10;&#10;&#10;no[shape=&quot;box&quot;, style=rounded, label=&quot;No microversion needed&quot;];&#10;yes[shape=&quot;box&quot;, style=rounded, label=&quot;Yes, you need a microversion&quot;];&#10;no2[shape=&quot;box&quot;, style=rounded, label=&quot;No microversion needed, it's&#10;a bug&quot;];&#10;&#10;silent_fail -&gt; ret_500[label=&quot; no&quot;];&#10;silent_fail -&gt; no2[label=&quot;yes&quot;];&#10;&#10; ret_500 -&gt; no2[label=&quot;yes [1]&quot;];&#10; ret_500 -&gt; new_error[label=&quot; no&quot;];&#10;&#10; new_error -&gt; new_attr[label=&quot; no&quot;];&#10; new_error -&gt; yes[label=&quot;yes&quot;];&#10;&#10; new_attr -&gt; new_param[label=&quot; no&quot;];&#10; new_attr -&gt; yes[label=&quot;yes&quot;];&#10;&#10; new_param -&gt; new_resource[label=&quot; no&quot;];&#10; new_param -&gt; yes[label=&quot;yes&quot;];&#10;&#10; new_resource -&gt; no[label=&quot; no&quot;];&#10; new_resource -&gt; yes[label=&quot;yes&quot;];&#10;&#10;{rank=same; yes new_attr}&#10;{rank=same; no2 ret_500}&#10;{rank=min; silent_fail}&#10;}" options="{}">
            </graphviz>
            <paragraph><strong>Footnotes</strong></paragraph>
            <footnote auto="1" backrefs="id2" ids="f1" names="f1">
                <label>1</label>
                <paragraph>When fixing 500 errors that previously caused stack traces, try
                    to map the new error into the existing set of errors that API call
                    could previously return (400 if nothing else is appropriate). Changing
                    the set of allowed status codes from a request is changing the
                    contract, and should be part of a microversion (except in <footnote_reference auto="1" ids="id3" refid="f2">2</footnote_reference>).</paragraph>
                <paragraph>The reason why we are so strict on contract is that we'd like
                    application writers to be able to know, for sure, what the contract is
                    at every microversion in Nova. If they do not, they will need to write
                    conditional code in their application to handle ambiguities.</paragraph>
                <paragraph>When in doubt, consider application authors. If it would work with no
                    client side changes on both Nova versions, you probably don't need a
                    microversion. If, on the other hand, there is any ambiguity, a
                    microversion is probably needed.</paragraph>
            </footnote>
            <footnote auto="1" backrefs="id1 id3" ids="f2" names="f2">
                <label>2</label>
                <paragraph>The exception to not needing a microversion when returning a
                    previously unspecified error code is the 400, 403, 404 and 415 cases. This is
                    considered OK to return even if previously unspecified in the code since
                    it's implied given keystone authentication can fail with a 403 and API
                    validation can fail with a 400 for invalid json request body. Request to
                    url/resource that does not exist always fails with 404. Invalid content types
                    are handled before API methods are called which results in a 415.</paragraph>
                <block_quote>
                    <note>
                        <paragraph>When in doubt about whether or not a microversion is required
                            for changing an error response code, consult the <reference name="Nova API subteam" refuri="https://wiki.openstack.org/wiki/Meetings/NovaAPI">Nova API subteam</reference>.</paragraph>
                    </note>
                </block_quote>
            </footnote>
            <target ids="nova-api-subteam" names="nova\ api\ subteam" refuri="https://wiki.openstack.org/wiki/Meetings/NovaAPI"></target>
        </section>
        <section ids="when-a-microversion-is-not-needed" names="when\ a\ microversion\ is\ not\ needed">
            <title>When a microversion is not needed</title>
            <paragraph>A microversion is not needed in the following situation:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>the response</paragraph>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph>Changing the error message without changing the response code
                                does not require a new microversion.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>Removing an inapplicable HTTP header, for example, suppose the Retry-After
                                HTTP header is being returned with a 4xx code. This header should only be
                                returned with a 503 or 3xx response, so it may be removed without bumping
                                the microversion.</paragraph>
                        </list_item>
                    </bullet_list>
                </list_item>
            </bullet_list>
        </section>
        <section ids="in-code" names="in\ code">
            <title>In Code</title>
            <paragraph>In <literal>nova/api/openstack/wsgi.py</literal> we define an <literal>@api_version</literal> decorator
                which is intended to be used on top-level Controller methods. It is
                not appropriate for lower-level methods. Some examples:</paragraph>
            <section ids="adding-a-new-api-method" names="adding\ a\ new\ api\ method">
                <title>Adding a new API method</title>
                <paragraph>In the controller class:</paragraph>
                <literal_block xml:space="preserve">@wsgi.Controller.api_version("2.4")
def my_api_method(self, req, id):
    ....</literal_block>
                <paragraph>This method would only be available if the caller had specified an
                    <literal>OpenStack-API-Version</literal> of &gt;= <literal>2.4</literal>. If they had specified a
                    lower version (or not specified it and received the default of <literal>2.1</literal>)
                    the server would respond with <literal>HTTP/404</literal>.</paragraph>
            </section>
            <section ids="removing-an-api-method" names="removing\ an\ api\ method">
                <title>Removing an API method</title>
                <paragraph>In the controller class:</paragraph>
                <literal_block xml:space="preserve">@wsgi.Controller.api_version("2.1", "2.4")
def my_api_method(self, req, id):
    ....</literal_block>
                <paragraph>This method would only be available if the caller had specified an
                    <literal>OpenStack-API-Version</literal> of &lt;= <literal>2.4</literal>. If <literal>2.5</literal> or later
                    is specified the server will respond with <literal>HTTP/404</literal>.</paragraph>
            </section>
            <section ids="changing-a-method-s-behavior" names="changing\ a\ method's\ behavior">
                <title>Changing a method's behavior</title>
                <paragraph>In the controller class:</paragraph>
                <literal_block xml:space="preserve">@wsgi.Controller.api_version("2.1", "2.3")
def my_api_method(self, req, id):
    .... method_1 ...

@wsgi.Controller.api_version("2.4")  # noqa
def my_api_method(self, req, id):
    .... method_2 ...</literal_block>
                <paragraph>If a caller specified <literal>2.1</literal>, <literal>2.2</literal> or <literal>2.3</literal> (or received the
                    default of <literal>2.1</literal>) they would see the result from <literal>method_1</literal>,
                    <literal>2.4</literal> or later <literal>method_2</literal>.</paragraph>
                <paragraph>It is vital that the two methods have the same name, so the second of
                    them will need <literal># noqa</literal> to avoid failing flake8's <literal>F811</literal> rule. The
                    two methods may be different in any kind of semantics (schema
                    validation, return values, response codes, etc)</paragraph>
            </section>
            <section ids="a-change-in-schema-only" names="a\ change\ in\ schema\ only">
                <title>A change in schema only</title>
                <paragraph>If there is no change to the method, only to the schema that is used for
                    validation, you can add a version range to the <literal>validation.schema</literal>
                    decorator:</paragraph>
                <literal_block xml:space="preserve">@wsgi.Controller.api_version("2.1")
@validation.schema(dummy_schema.dummy, "2.3", "2.8")
@validation.schema(dummy_schema.dummy2, "2.9")
def update(self, req, id, body):
    ....</literal_block>
                <paragraph>This method will be available from version <literal>2.1</literal>, validated according to
                    <literal>dummy_schema.dummy</literal> from <literal>2.3</literal> to <literal>2.8</literal>, and validated according to
                    <literal>dummy_schema.dummy2</literal> from <literal>2.9</literal> onward.</paragraph>
            </section>
            <section ids="when-not-using-decorators" names="when\ not\ using\ decorators">
                <title>When not using decorators</title>
                <paragraph>When you don't want to use the <literal>@api_version</literal> decorator on a method
                    or you want to change behavior within a method (say it leads to
                    simpler or simply a lot less code) you can directly test for the
                    requested version with a method as long as you have access to the api
                    request object (commonly called <literal>req</literal>). Every API method has an
                    api_version_request object attached to the req object and that can be
                    used to modify behavior based on its value:</paragraph>
                <literal_block xml:space="preserve">def index(self, req):
    &lt;common code&gt;

    req_version = req.api_version_request
    req1_min = api_version_request.APIVersionRequest("2.1")
    req1_max = api_version_request.APIVersionRequest("2.5")
    req2_min = api_version_request.APIVersionRequest("2.6")
    req2_max = api_version_request.APIVersionRequest("2.10")

    if req_version.matches(req1_min, req1_max):
        ....stuff....
    elif req_version.matches(req2min, req2_max):
        ....other stuff....
    elif req_version &gt; api_version_request.APIVersionRequest("2.10"):
        ....more stuff.....

    &lt;common code&gt;</literal_block>
                <paragraph>The first argument to the matches method is the minimum acceptable version
                    and the second is maximum acceptable version. A specified version can be null:</paragraph>
                <literal_block xml:space="preserve">null_version = APIVersionRequest()</literal_block>
                <paragraph>If the minimum version specified is null then there is no restriction on
                    the minimum version, and likewise if the maximum version is null there
                    is no restriction the maximum version. Alternatively a one sided comparison
                    can be used as in the example above.</paragraph>
            </section>
        </section>
        <section ids="other-necessary-changes" names="other\ necessary\ changes">
            <title>Other necessary changes</title>
            <paragraph>If you are adding a patch which adds a new microversion, it is
                necessary to add changes to other places which describe your change:</paragraph>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph>Update <literal>REST_API_VERSION_HISTORY</literal> in
                        <literal>nova/api/openstack/api_version_request.py</literal></paragraph>
                </list_item>
                <list_item>
                    <paragraph>Update <literal>_MAX_API_VERSION</literal> in
                        <literal>nova/api/openstack/api_version_request.py</literal></paragraph>
                </list_item>
                <list_item>
                    <paragraph>Add a verbose description to
                        <literal>nova/api/openstack/compute/rest_api_version_history.rst</literal>.  There should
                        be enough information that it could be used by the docs team for
                        release notes.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Update the expected versions in affected tests, for example in
                        <literal>nova/tests/unit/api/openstack/compute/test_versions.py</literal>.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Update the get versions api sample file:
                        <literal>doc/api_samples/versions/versions-get-resp.json</literal> and
                        <literal>doc/api_samples/versions/v21-version-get-resp.json</literal>.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Make a new commit to python-novaclient and update corresponding
                        files to enable the newly added microversion API.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>If the microversion changes the response schema, a new schema and test for
                        the microversion must be added to Tempest.</paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="allocating-a-microversion" names="allocating\ a\ microversion">
            <title>Allocating a microversion</title>
            <paragraph>If you are adding a patch which adds a new microversion, it is
                necessary to allocate the next microversion number. Except under
                extremely unusual circumstances and this would have been mentioned in
                the nova spec for the change, the minor number of <literal>_MAX_API_VERSION</literal>
                will be incremented. This will also be the new microversion number for
                the API change.</paragraph>
            <paragraph>It is possible that multiple microversion patches would be proposed in
                parallel and the microversions would conflict between patches.  This
                will cause a merge conflict. We don't reserve a microversion for each
                patch in advance as we don't know the final merge order. Developers
                may need over time to rebase their patch calculating a new version
                number as above based on the updated value of <literal>_MAX_API_VERSION</literal>.</paragraph>
        </section>
        <section ids="testing-microversioned-api-methods" names="testing\ microversioned\ api\ methods">
            <title>Testing Microversioned API Methods</title>
            <paragraph>Testing a microversioned API method is very similar to a normal controller
                method test, you just need to add the <literal>OpenStack-API-Version</literal>
                header, for example:</paragraph>
            <literal_block xml:space="preserve">req = fakes.HTTPRequest.blank('/testable/url/endpoint')
req.headers = {'OpenStack-API-Version': 'compute 2.28'}
req.api_version_request = api_version.APIVersionRequest('2.6')

controller = controller.TestableController()

res = controller.index(req)
... assertions about the response ...</literal_block>
            <paragraph>For many examples of testing, the canonical examples are in
                <literal>nova/tests/unit/api/openstack/compute/test_microversions.py</literal>.</paragraph>
        </section>
    </section>
</document>
