<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document source="/home/fbaumanis/openstack/soc8_test/openstack_repo/nova/doc/source/admin/flavors.rst">
    <section ids="flavors" names="flavors">
        <title>Flavors</title>
        <paragraph>Admin users can use the <literal_strong classes="command">openstack flavor</literal_strong> command to customize and
            manage flavors. To see information for this command, run:</paragraph>
        <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve">$ openstack flavor --help
Command "flavor" matches:
  flavor create
  flavor delete
  flavor list
  flavor set
  flavor show
  flavor unset</literal_block>
        <note>
            <paragraph>Configuration rights can be delegated to additional users by redefining
                the access controls for <literal>os_compute_api:os-flavor-manage</literal> in
                <literal>/etc/nova/policy.json</literal> on the <literal>nova-api</literal> server.</paragraph>
        </note>
        <paragraph>Flavors define these elements:</paragraph>
        <target refid="index-0"></target>
        <todo_node classes="admonition-todo" ids="index-0">
            <title>Todo</title>
            <paragraph>This would be much easier to read as a list-table or similar</paragraph>
        </todo_node>
        <table>
            <tgroup cols="2">
                <colspec colwidth="13"></colspec>
                <colspec colwidth="63"></colspec>
                <thead>
                    <row>
                        <entry>
                            <paragraph>Element</paragraph>
                        </entry>
                        <entry>
                            <paragraph>Description</paragraph>
                        </entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>
                            <paragraph>Name</paragraph>
                        </entry>
                        <entry>
                            <paragraph>A descriptive name. XX.SIZE_NAME is typically not required,
                                though some third party tools may rely on it.</paragraph>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <paragraph>Memory MB</paragraph>
                        </entry>
                        <entry>
                            <paragraph>Instance memory in megabytes.</paragraph>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <paragraph>Disk</paragraph>
                        </entry>
                        <entry>
                            <paragraph>Virtual root disk size in gigabytes. This is an ephemeral disk that the base image is copied into. When booting from a persistent volume it is not used. The "0" size is a special case which uses the native base image size as the size of the
                                ephemeral root volume. However, in this case the filter
                                scheduler cannot select the compute host based on the virtual
                                image size. Therefore 0 should only be used for volume booted
                                instances or for testing purposes.</paragraph>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <paragraph>Ephemeral</paragraph>
                        </entry>
                        <entry>
                            <paragraph>Specifies the size of a secondary ephemeral data disk. This
                                is an empty, unformatted disk and exists only for the life of the instance. Default value is <literal>0</literal>.</paragraph>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <paragraph>Swap</paragraph>
                        </entry>
                        <entry>
                            <paragraph>Optional swap space allocation for the instance. Default
                                value is <literal>0</literal>.</paragraph>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <paragraph>VCPUs</paragraph>
                        </entry>
                        <entry>
                            <paragraph>Number of virtual CPUs presented to the instance.</paragraph>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <paragraph>RXTX Factor</paragraph>
                        </entry>
                        <entry>
                            <paragraph>Optional property allows created servers to have a different
                                bandwidth cap than that defined in the network they are attached to. This factor is multiplied by the rxtx_base property of the network. Default value is <literal>1.0</literal>. That is, the same
                                as attached network. This parameter is only available for Xen
                                or NSX based systems.</paragraph>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <paragraph>Is Public</paragraph>
                        </entry>
                        <entry>
                            <paragraph>Boolean value, whether flavor is available to all users or private to the project it was created in. Defaults to <literal>True</literal>.</paragraph>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <paragraph>Extra Specs</paragraph>
                        </entry>
                        <entry>
                            <paragraph>Key and value pairs that define on which compute nodes a flavor can run. These pairs must match corresponding pairs on the compute nodes. Use to implement special resources, such as flavors that run on only compute nodes with GPU hardware.</paragraph>
                        </entry>
                    </row>
                </tbody>
            </tgroup>
        </table>
        <note>
            <paragraph>Flavor customization can be limited by the hypervisor in use. For example
                the libvirt driver enables quotas on CPUs available to a VM, disk tuning,
                bandwidth I/O, watchdog behavior, random number generator device control,
                and instance VIF traffic control.</paragraph>
        </note>
        <section ids="is-public" names="is\ public">
            <title>Is Public</title>
            <paragraph>Flavors can be assigned to particular projects. By default, a flavor is public
                and available to all projects. Private flavors are only accessible to those on
                the access list and are invisible to other projects. To create and assign a
                private flavor to a project, run this command:</paragraph>
            <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve">$ openstack flavor create --private p1.medium --id auto --ram 512 --disk 40 --vcpus 4</literal_block>
        </section>
        <section ids="extra-specs" names="extra\ specs">
            <title>Extra Specs</title>
            <definition_list>
                <definition_list_item>
                    <term>CPU limits</term>
                    <definition>
                        <paragraph>You can configure the CPU limits with control parameters with the <literal>nova</literal>
                            client. For example, to configure the I/O limit, use:</paragraph>
                        <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve">$ openstack flavor set FLAVOR-NAME \
    --property quota:read_bytes_sec=10240000 \
    --property quota:write_bytes_sec=10240000</literal_block>
                        <paragraph>Use these optional parameters to control weight shares, enforcement intervals
                            for runtime quotas, and a quota for maximum allowed bandwidth:</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph><literal>cpu_shares</literal>: Specifies the proportional weighted share for the domain.
                                    If this element is omitted, the service defaults to the OS provided
                                    defaults. There is no unit for the value; it is a relative measure based on
                                    the setting of other VMs. For example, a VM configured with value 2048 gets
                                    twice as much CPU time as a VM configured with value 1024.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal>cpu_shares_level</literal>: On VMware, specifies the allocation level. Can be
                                    <literal>custom</literal>, <literal>high</literal>, <literal>normal</literal>, or <literal>low</literal>. If you choose <literal>custom</literal>, set
                                    the number of shares using <literal>cpu_shares_share</literal>.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal>cpu_period</literal>: Specifies the enforcement interval (unit: microseconds)
                                    for QEMU and LXC hypervisors. Within a period, each VCPU of the domain is
                                    not allowed to consume more than the quota worth of runtime. The value
                                    should be in range <literal>[1000, 1000000]</literal>.  A period with value 0 means no
                                    value.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal>cpu_limit</literal>: Specifies the upper limit for VMware machine CPU allocation
                                    in MHz. This parameter ensures that a machine never uses more than the
                                    defined amount of CPU time. It can be used to enforce a limit on the
                                    machine's CPU performance.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal>cpu_reservation</literal>: Specifies the guaranteed minimum CPU reservation in
                                    MHz for VMware. This means that if needed, the machine will definitely get
                                    allocated the reserved amount of CPU cycles.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal>cpu_quota</literal>: Specifies the maximum allowed bandwidth (unit:
                                    microseconds). A domain with a negative-value quota indicates that the
                                    domain has infinite bandwidth, which means that it is not bandwidth
                                    controlled. The value should be in range <literal>[1000, 18446744073709551]</literal> or
                                    less than 0. A quota with value 0 means no value. You can use this feature
                                    to ensure that all vCPUs run at the same speed. For example:</paragraph>
                                <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve">$ openstack flavor set FLAVOR-NAME \
    --property quota:cpu_quota=10000 \
    --property quota:cpu_period=20000</literal_block>
                                <paragraph>In this example, an instance of <literal>FLAVOR-NAME</literal> can only consume a maximum
                                    of 50% CPU of a physical CPU computing capability.</paragraph>
                            </list_item>
                        </bullet_list>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term>Memory limits</term>
                    <definition>
                        <paragraph>For VMware, you can configure the memory limits with control parameters.</paragraph>
                        <paragraph>Use these optional parameters to limit the memory allocation, guarantee
                            minimum memory reservation, and to specify shares used in case of resource
                            contention:</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph><literal>memory_limit</literal>: Specifies the upper limit for VMware machine memory
                                    allocation in MB. The utilization of a virtual machine will not exceed this
                                    limit, even if there are available resources. This is typically used to
                                    ensure a consistent performance of virtual machines independent of
                                    available resources.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal>memory_reservation</literal>: Specifies the guaranteed minimum memory reservation
                                    in MB for VMware. This means the specified amount of memory will definitely
                                    be allocated to the machine.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal>memory_shares_level</literal>: On VMware, specifies the allocation level.  This
                                    can be <literal>custom</literal>, <literal>high</literal>, <literal>normal</literal> or <literal>low</literal>. If you choose
                                    <literal>custom</literal>, set the number of shares using <literal>memory_shares_share</literal>.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal>memory_shares_share</literal>: Specifies the number of shares allocated in the
                                    event that <literal>custom</literal> is used. There is no unit for this value. It is a
                                    relative measure based on the settings for other VMs.  For example:</paragraph>
                                <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve">$ openstack flavor set FLAVOR-NAME \
    --property quota:memory_shares_level=custom \
    --property quota:memory_shares_share=15</literal_block>
                            </list_item>
                        </bullet_list>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term>Disk I/O limits</term>
                    <definition>
                        <paragraph>For VMware, you can configure the resource limits for disk with control
                            parameters.</paragraph>
                        <paragraph>Use these optional parameters to limit the disk utilization, guarantee disk
                            allocation, and to specify shares used in case of resource contention. This
                            allows the VMware driver to enable disk allocations for the running instance.</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph><literal>disk_io_limit</literal>: Specifies the upper limit for disk utilization in I/O
                                    per second. The utilization of a virtual machine will not exceed this
                                    limit, even if there are available resources. The default value is -1 which
                                    indicates unlimited usage.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal>disk_io_reservation</literal>: Specifies the guaranteed minimum disk allocation
                                    in terms of Input/output Operations Per Second (IOPS).</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal>disk_io_shares_level</literal>: Specifies the allocation level. This can be
                                    <literal>custom</literal>, <literal>high</literal>, <literal>normal</literal> or <literal>low</literal>.  If you choose custom, set the
                                    number of shares using <literal>disk_io_shares_share</literal>.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal>disk_io_shares_share</literal>: Specifies the number of shares allocated in the
                                    event that <literal>custom</literal> is used.  When there is resource contention, this
                                    value is used to determine the resource allocation.</paragraph>
                                <paragraph>The example below sets the <literal>disk_io_reservation</literal> to 2000 IOPS.</paragraph>
                                <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve">$ openstack flavor set FLAVOR-NAME \
    --property quota:disk_io_reservation=2000</literal_block>
                            </list_item>
                        </bullet_list>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term>Disk tuning</term>
                    <definition>
                        <paragraph>Using disk I/O quotas, you can set maximum disk write to 10 MB per second for
                            a VM user. For example:</paragraph>
                        <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve">$ openstack flavor set FLAVOR-NAME \
    --property quota:disk_write_bytes_sec=10485760</literal_block>
                        <paragraph>The disk I/O options are:</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph><literal>disk_read_bytes_sec</literal></paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal>disk_read_iops_sec</literal></paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal>disk_write_bytes_sec</literal></paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal>disk_write_iops_sec</literal></paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal>disk_total_bytes_sec</literal></paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal>disk_total_iops_sec</literal></paragraph>
                            </list_item>
                        </bullet_list>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term>Bandwidth I/O</term>
                    <definition>
                        <paragraph>The vif I/O options are:</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph><literal>vif_inbound_average</literal></paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal>vif_inbound_burst</literal></paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal>vif_inbound_peak</literal></paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal>vif_outbound_average</literal></paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal>vif_outbound_burst</literal></paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal>vif_outbound_peak</literal></paragraph>
                            </list_item>
                        </bullet_list>
                        <paragraph>Incoming and outgoing traffic can be shaped independently. The bandwidth
                            element can have at most, one inbound and at most, one outbound child
                            element. If you leave any of these child elements out, no quality of service
                            (QoS) is applied on that traffic direction. So, if you want to shape only the
                            network's incoming traffic, use inbound only (and vice versa). Each element
                            has one mandatory attribute average, which specifies the average bit rate on
                            the interface being shaped.</paragraph>
                        <paragraph>There are also two optional attributes (integer): <literal>peak</literal>, which specifies
                            the maximum rate at which a bridge can send data (kilobytes/second), and
                            <literal>burst</literal>, the amount of bytes that can be burst at peak speed (kilobytes).
                            The rate is shared equally within domains connected to the network.</paragraph>
                        <paragraph>The example below sets network traffic bandwidth limits for existing flavor
                            as follows:</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>Outbound traffic:</paragraph>
                                <bullet_list bullet="-">
                                    <list_item>
                                        <paragraph>average: 262 Mbps (32768 kilobytes/second)</paragraph>
                                    </list_item>
                                    <list_item>
                                        <paragraph>peak: 524 Mbps (65536 kilobytes/second)</paragraph>
                                    </list_item>
                                    <list_item>
                                        <paragraph>burst: 65536 kilobytes</paragraph>
                                    </list_item>
                                </bullet_list>
                            </list_item>
                            <list_item>
                                <paragraph>Inbound traffic:</paragraph>
                                <bullet_list bullet="-">
                                    <list_item>
                                        <paragraph>average: 262 Mbps (32768 kilobytes/second)</paragraph>
                                    </list_item>
                                    <list_item>
                                        <paragraph>peak: 524 Mbps (65536 kilobytes/second)</paragraph>
                                    </list_item>
                                    <list_item>
                                        <paragraph>burst: 65536 kilobytes</paragraph>
                                    </list_item>
                                </bullet_list>
                            </list_item>
                        </bullet_list>
                        <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve">$ openstack flavor set FLAVOR-NAME \
    --property quota:vif_outbound_average=32768 \
    --property quota:vif_outbound_peak=65536 \
    --property quota:vif_outbound_burst=65536 \
    --property quota:vif_inbound_average=32768 \
    --property quota:vif_inbound_peak=65536 \
    --property quota:vif_inbound_burst=65536</literal_block>
                        <note>
                            <paragraph>All the speed limit values in above example are specified in
                                kilobytes/second. And burst values are in kilobytes. Values were converted
                                using 'Data rate units on Wikipedia
                                &lt;<reference refuri="https://en.wikipedia.org/wiki/Data_rate_units">https://en.wikipedia.org/wiki/Data_rate_units</reference>&gt;`_.</paragraph>
                        </note>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term>Watchdog behavior</term>
                    <definition>
                        <paragraph>For the libvirt driver, you can enable and set the behavior of a virtual
                            hardware watchdog device for each flavor. Watchdog devices keep an eye on the
                            guest server, and carry out the configured action, if the server hangs. The
                            watchdog uses the i6300esb device (emulating a PCI Intel 6300ESB). If
                            <literal>hw:watchdog_action</literal> is not specified, the watchdog is disabled.</paragraph>
                        <paragraph>To set the behavior, use:</paragraph>
                        <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve">$ openstack flavor set FLAVOR-NAME --property hw:watchdog_action=ACTION</literal_block>
                        <paragraph>Valid ACTION values are:</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph><literal>disabled</literal>: (default) The device is not attached.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal>reset</literal>: Forcefully reset the guest.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal>poweroff</literal>: Forcefully power off the guest.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal>pause</literal>: Pause the guest.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal>none</literal>: Only enable the watchdog; do nothing if the server hangs.</paragraph>
                            </list_item>
                        </bullet_list>
                        <note>
                            <paragraph>Watchdog behavior set using a specific image's properties will override
                                behavior set using flavors.</paragraph>
                        </note>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term>Random-number generator</term>
                    <definition>
                        <paragraph>If a random-number generator device has been added to the instance through
                            its image properties, the device can be enabled and configured using:</paragraph>
                        <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve">$ openstack flavor set FLAVOR-NAME \
    --property hw_rng:allowed=True \
    --property hw_rng:rate_bytes=RATE-BYTES \
    --property hw_rng:rate_period=RATE-PERIOD</literal_block>
                        <paragraph>Where:</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>RATE-BYTES: (integer) Allowed amount of bytes that the guest can read from
                                    the host's entropy per period.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>RATE-PERIOD: (integer) Duration of the read period in seconds.</paragraph>
                            </list_item>
                        </bullet_list>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term>CPU topology</term>
                    <definition>
                        <paragraph>For the libvirt driver, you can define the topology of the processors in the
                            virtual machine using properties. The properties with <literal>max</literal> limit the
                            number that can be selected by the user with image properties.</paragraph>
                        <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve">$ openstack flavor set FLAVOR-NAME \
    --property hw:cpu_sockets=FLAVOR-SOCKETS \
    --property hw:cpu_cores=FLAVOR-CORES \
    --property hw:cpu_threads=FLAVOR-THREADS \
    --property hw:cpu_max_sockets=FLAVOR-SOCKETS \
    --property hw:cpu_max_cores=FLAVOR-CORES \
    --property hw:cpu_max_threads=FLAVOR-THREADS</literal_block>
                        <paragraph>Where:</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>FLAVOR-SOCKETS: (integer) The number of sockets for the guest VM. By
                                    default, this is set to the number of vCPUs requested.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>FLAVOR-CORES: (integer) The number of cores per socket for the guest VM. By
                                    default, this is set to <literal>1</literal>.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>FLAVOR-THREADS: (integer) The number of threads per core for the guest VM.
                                    By default, this is set to <literal>1</literal>.</paragraph>
                            </list_item>
                        </bullet_list>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term>CPU pinning policy</term>
                    <definition>
                        <paragraph>For the libvirt driver, you can pin the virtual CPUs (vCPUs) of instances to
                            the host's physical CPU cores (pCPUs) using properties. You can further
                            refine this by stating how hardware CPU threads in a simultaneous
                            multithreading-based (SMT) architecture be used. These configurations will
                            result in improved per-instance determinism and performance.</paragraph>
                        <note>
                            <paragraph>SMT-based architectures include Intel processors with Hyper-Threading
                                technology. In these architectures, processor cores share a number of
                                components with one or more other cores. Cores in such architectures are
                                commonly referred to as hardware threads, while the cores that a given
                                core share components with are known as thread siblings.</paragraph>
                        </note>
                        <note>
                            <paragraph>Host aggregates should be used to separate these pinned instances from
                                unpinned instances as the latter will not respect the resourcing
                                requirements of the former.</paragraph>
                        </note>
                        <literal_block classes="code console" xml:space="preserve"><inline classes="generic prompt">$</inline> openstack flavor <inline classes="name builtin">set</inline> FLAVOR-NAME <inline classes="literal string escape">\
</inline>    --property hw:cpu_policy<inline classes="operator">=</inline>CPU-POLICY <inline classes="literal string escape">\
</inline>    --property hw:cpu_thread_policy<inline classes="operator">=</inline>CPU-THREAD-POLICY</literal_block>
                        <paragraph>Valid CPU-POLICY values are:</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph><literal>shared</literal>: (default) The guest vCPUs will be allowed to freely float
                                    across host pCPUs, albeit potentially constrained by NUMA policy.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal>dedicated</literal>: The guest vCPUs will be strictly pinned to a set of host
                                    pCPUs. In the absence of an explicit vCPU topology request, the drivers
                                    typically expose all vCPUs as sockets with one core and one thread.  When
                                    strict CPU pinning is in effect the guest CPU topology will be setup to
                                    match the topology of the CPUs to which it is pinned. This option implies
                                    an overcommit ratio of 1.0. For example, if a two vCPU guest is pinned to a
                                    single host core with two threads, then the guest will get a topology of
                                    one socket, one core, two threads.</paragraph>
                            </list_item>
                        </bullet_list>
                        <paragraph>Valid CPU-THREAD-POLICY values are:</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph><literal>prefer</literal>: (default) The host may or may not have an SMT architecture.
                                    Where an SMT architecture is present, thread siblings are preferred.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal>isolate</literal>: The host must not have an SMT architecture or must emulate a
                                    non-SMT architecture. If the host does not have an SMT architecture, each
                                    vCPU is placed on a different core as expected. If the host does have an
                                    SMT architecture - that is, one or more cores have thread siblings - then
                                    each vCPU is placed on a different physical core. No vCPUs from other
                                    guests are placed on the same core. All but one thread sibling on each
                                    utilized core is therefore guaranteed to be unusable.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal>require</literal>: The host must have an SMT architecture. Each vCPU is allocated
                                    on thread siblings. If the host does not have an SMT architecture, then it
                                    is not used. If the host has an SMT architecture, but not enough cores with
                                    free thread siblings are available, then scheduling fails.</paragraph>
                            </list_item>
                        </bullet_list>
                        <note>
                            <paragraph>The <literal>hw:cpu_thread_policy</literal> option is only valid if <literal>hw:cpu_policy</literal> is
                                set to <literal>dedicated</literal>.</paragraph>
                        </note>
                    </definition>
                </definition_list_item>
            </definition_list>
            <target refid="extra-specs-numa-topology"></target>
            <definition_list ids="extra-specs-numa-topology" names="extra-specs-numa-topology">
                <definition_list_item>
                    <term>NUMA topology</term>
                    <definition>
                        <paragraph>For the libvirt driver, you can define the host NUMA placement for the
                            instance vCPU threads as well as the allocation of instance vCPUs and memory
                            from the host NUMA nodes. For flavors whose memory and vCPU allocations are
                            larger than the size of NUMA nodes in the compute hosts, the definition of a
                            NUMA topology allows hosts to better utilize NUMA and improve performance of
                            the instance OS.</paragraph>
                        <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve">$ openstack flavor set FLAVOR-NAME \
    --property hw:numa_nodes=FLAVOR-NODES \
    --property hw:numa_cpus.N=FLAVOR-CORES \
    --property hw:numa_mem.N=FLAVOR-MEMORY</literal_block>
                        <paragraph>Where:</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>FLAVOR-NODES: (integer) The number of host NUMA nodes to restrict execution
                                    of instance vCPU threads to. If not specified, the vCPU threads can run on
                                    any number of the host NUMA nodes available.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>N: (integer) The instance NUMA node to apply a given CPU or memory
                                    configuration to, where N is in the range <literal>0</literal> to <literal>FLAVOR-NODES - 1</literal>.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>FLAVOR-CORES: (comma-separated list of integers) A list of instance vCPUs
                                    to map to instance NUMA node N. If not specified, vCPUs are evenly divided
                                    among available NUMA nodes.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>FLAVOR-MEMORY: (integer) The number of MB of instance memory to map to
                                    instance NUMA node N. If not specified, memory is evenly divided among
                                    available NUMA nodes.</paragraph>
                            </list_item>
                        </bullet_list>
                        <note>
                            <paragraph><literal>hw:numa_cpus.N</literal> and <literal>hw:numa_mem.N</literal> are only valid if
                                <literal>hw:numa_nodes</literal> is set. Additionally, they are only required if the
                                instance's NUMA nodes have an asymmetrical allocation of CPUs and RAM
                                (important for some NFV workloads).</paragraph>
                        </note>
                        <note>
                            <paragraph>The <literal>N</literal> parameter is an index of <emphasis>guest</emphasis> NUMA nodes and may not
                                correspond to <emphasis>host</emphasis> NUMA nodes. For example, on a platform with two NUMA
                                nodes, the scheduler may opt to place guest NUMA node 0, as referenced in
                                <literal>hw:numa_mem.0</literal> on host NUMA node 1 and vice versa.  Similarly, the
                                integers used for <literal>FLAVOR-CORES</literal> are indexes of <emphasis>guest</emphasis> vCPUs and may
                                not correspond to <emphasis>host</emphasis> CPUs. As such, this feature cannot be used to
                                constrain instances to specific host CPUs or NUMA nodes.</paragraph>
                        </note>
                        <warning>
                            <paragraph>If the combined values of <literal>hw:numa_cpus.N</literal> or <literal>hw:numa_mem.N</literal> are
                                greater than the available number of CPUs or memory respectively, an
                                exception is raised.</paragraph>
                        </warning>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term>Large pages allocation</term>
                    <definition>
                        <paragraph>You can configure the size of large pages used to back the VMs.</paragraph>
                        <literal_block classes="code console" xml:space="preserve"><inline classes="generic prompt">$</inline> openstack flavor <inline classes="name builtin">set</inline> FLAVOR-NAME <inline classes="literal string escape">\
</inline>    --property hw:mem_page_size<inline classes="operator">=</inline>PAGE_SIZE</literal_block>
                        <paragraph>Valid <literal>PAGE_SIZE</literal> values are:</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph><literal>small</literal>: (default) The smallest page size is used. Example: 4 KB on x86.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal>large</literal>: Only use larger page sizes for guest RAM. Example: either 2 MB
                                    or 1 GB on x86.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal>any</literal>: It is left up to the compute driver to decide. In this case, the
                                    libvirt driver might try to find large pages, but fall back to small pages.
                                    Other drivers may choose alternate policies for <literal>any</literal>.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>pagesize: (string) An explicit page size can be set if the workload has
                                    specific requirements. This value can be an integer value for the page size
                                    in KB, or can use any standard suffix. Example: <literal>4KB</literal>, <literal>2MB</literal>,
                                    <literal>2048</literal>, <literal>1GB</literal>.</paragraph>
                            </list_item>
                        </bullet_list>
                        <note>
                            <paragraph>Large pages can be enabled for guest RAM without any regard to whether the
                                guest OS will use them or not. If the guest OS chooses not to use huge
                                pages, it will merely see small pages as before. Conversely, if a guest OS
                                does intend to use huge pages, it is very important that the guest RAM be
                                backed by huge pages. Otherwise, the guest OS will not be getting the
                                performance benefit it is expecting.</paragraph>
                        </note>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term>PCI passthrough</term>
                    <definition>
                        <paragraph>You can assign PCI devices to a guest by specifying them in the flavor.</paragraph>
                        <literal_block classes="code console" xml:space="preserve"><inline classes="generic prompt">$</inline> openstack flavor <inline classes="name builtin">set</inline> FLAVOR-NAME <inline classes="literal string escape">\
</inline>    --property pci_passthrough:alias<inline classes="operator">=</inline>ALIAS:COUNT</literal_block>
                        <paragraph>Where:</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>ALIAS: (string) The alias which correspond to a particular PCI device class
                                    as configured in the nova configuration file (see
                                    <reference internal="True" refuri="../configuration/config"><inline classes="doc">Configuration Options</inline></reference>).</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>COUNT: (integer) The amount of PCI devices of type ALIAS to be assigned to
                                    a guest.</paragraph>
                            </list_item>
                        </bullet_list>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term>Secure Boot</term>
                    <definition>
                        <paragraph>When your Compute services use the Hyper-V hypervisor, you can enable secure
                            boot for Windows and Linux instances.</paragraph>
                        <literal_block classes="code console" xml:space="preserve"><inline classes="generic prompt">$</inline> openstack flavor <inline classes="name builtin">set</inline> FLAVOR-NAME <inline classes="literal string escape">\
</inline>    --property os:secure_boot<inline classes="operator">=</inline>SECURE_BOOT_OPTION</literal_block>
                        <paragraph>Valid <literal>SECURE_BOOT_OPTION</literal> values are:</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph><literal>required</literal>: Enable Secure Boot for instances running with this flavor.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><literal>disabled</literal> or <literal>optional</literal>: (default) Disable Secure Boot for instances
                                    running with this flavor.</paragraph>
                            </list_item>
                        </bullet_list>
                    </definition>
                </definition_list_item>
            </definition_list>
        </section>
    </section>
</document>
