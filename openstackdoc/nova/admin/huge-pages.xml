<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document source="/home/fbaumanis/openstack/soc8_test/openstack_repo/nova/doc/source/admin/huge-pages.rst">
    <section ids="huge-pages" names="huge\ pages">
        <title>Huge pages</title>
        <paragraph>The huge page feature in OpenStack provides important performance improvements
            for applications that are highly memory IO-bound.</paragraph>
        <note>
            <paragraph>Huge pages may also be referred to hugepages or large pages, depending on
                the source. These terms are synonyms.</paragraph>
        </note>
        <section ids="pages-the-tlb-and-huge-pages" names="pages,\ the\ tlb\ and\ huge\ pages">
            <title>Pages, the TLB and huge pages</title>
            <definition_list>
                <definition_list_item>
                    <term>Pages</term>
                    <definition>
                        <paragraph>Physical memory is segmented into a series of contiguous regions called
                            pages. Each page contains a number of bytes, referred to as the page size.
                            The system retrieves memory by accessing entire pages, rather than byte by
                            byte.</paragraph>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term>Translation Lookaside Buffer (TLB)</term>
                    <definition>
                        <paragraph>A TLB is used to map the virtual addresses of pages to the physical addresses
                            in actual memory. The TLB is a cache and is not limitless, storing only the
                            most recent or frequently accessed pages. During normal operation, processes
                            will sometimes attempt to retrieve pages that are not stored in the cache.
                            This is known as a TLB miss and results in a delay as the processor iterates
                            through the pages themselves to find the missing address mapping.</paragraph>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term>Huge Pages</term>
                    <definition>
                        <paragraph>The standard page size in x86 systems is 4 kB. This is optimal for general
                            purpose computing but larger page sizes - 2 MB and 1 GB - are also available.
                            These larger page sizes are known as huge pages. Huge pages result in less
                            efficient memory usage as a process will not generally use all memory
                            available in each page. However, use of huge pages will result in fewer
                            overall pages and a reduced risk of TLB misses. For processes that have
                            significant memory requirements or are memory intensive, the benefits of huge
                            pages frequently outweigh the drawbacks.</paragraph>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term>Persistent Huge Pages</term>
                    <definition>
                        <paragraph>On Linux hosts, persistent huge pages are huge pages that are reserved
                            upfront. The HugeTLB provides for the mechanism for this upfront
                            configuration of huge pages. The HugeTLB allows for the allocation of varying
                            quantities of different huge page sizes. Allocation can be made at boot time
                            or run time. Refer to the <reference name="Linux hugetlbfs guide" refuri="https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt">Linux hugetlbfs guide</reference> for more information.</paragraph>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term>Transparent Huge Pages (THP)</term>
                    <definition>
                        <paragraph>On Linux hosts, transparent huge pages are huge pages that are automatically
                            provisioned based on process requests. Transparent huge pages are provisioned
                            on a best effort basis, attempting to provision 2 MB huge pages if available
                            but falling back to 4 kB small pages if not. However, no upfront
                            configuration is necessary. Refer to the <reference name="Linux THP guide" refuri="https://www.kernel.org/doc/Documentation/vm/transhuge.txt">Linux THP guide</reference> for more
                            information.</paragraph>
                    </definition>
                </definition_list_item>
            </definition_list>
        </section>
        <section ids="enabling-huge-pages-on-the-host" names="enabling\ huge\ pages\ on\ the\ host">
            <title>Enabling huge pages on the host</title>
            <paragraph>Persistent huge pages are required owing to their guaranteed availability.
                However, persistent huge pages are not enabled by default in most environments.
                The steps for enabling huge pages differ from platform to platform and only the
                steps for Linux hosts are described here. On Linux hosts, the number of
                persistent huge pages on the host can be queried by checking <literal>/proc/meminfo</literal>:</paragraph>
            <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve">$ grep Huge /proc/meminfo
AnonHugePages:         0 kB
ShmemHugePages:        0 kB
HugePages_Total:       0
HugePages_Free:        0
HugePages_Rsvd:        0
HugePages_Surp:        0
Hugepagesize:       2048 kB</literal_block>
            <paragraph>In this instance, there are 0 persistent huge pages (<literal>HugePages_Total</literal>) and 0
                transparent huge pages (<literal>AnonHugePages</literal>) allocated. Huge pages can be
                allocated at boot time or run time. Huge pages require a contiguous area of
                memory - memory that gets increasingly fragmented the long a host is running.
                Identifying contiguous areas of memory is a issue for all huge page sizes, but
                it is particularly problematic for larger huge page sizes such as 1 GB huge
                pages. Allocating huge pages at boot time will ensure the correct number of huge
                pages is always available, while allocating them at run time can fail if memory
                has become too fragmented.</paragraph>
            <paragraph>To allocate huge pages at run time, the kernel boot parameters must be extended
                to include some huge page-specific parameters. This can be achieved by
                modifying <literal>/etc/default/grub</literal> and appending the <literal>hugepagesz</literal>,
                <literal>hugepages</literal>, and <literal>transparent_hugepages=never</literal> arguments to
                <literal>GRUB_CMDLINE_LINUX</literal>. To allocate, for example, 2048 persistent 2 MB huge
                pages at boot time, run:</paragraph>
            <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve"># echo 'GRUB_CMDLINE_LINUX="$GRUB_CMDLINE_LINUX hugepagesz=2M hugepages=2048 transparent_hugepage=never"' &gt; /etc/default/grub
$ grep GRUB_CMDLINE_LINUX /etc/default/grub
GRUB_CMDLINE_LINUX="..."
GRUB_CMDLINE_LINUX="$GRUB_CMDLINE_LINUX hugepagesz=2M hugepages=2048 transparent_hugepage=never"</literal_block>
            <important>
                <paragraph>Persistent huge pages are not usable by standard host OS processes. Ensure
                    enough free, non-huge page memory is reserved for these processes.</paragraph>
            </important>
            <paragraph>Reboot the host, then validate that huge pages are now available:</paragraph>
            <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve">$ grep "Huge" /proc/meminfo
AnonHugePages:         0 kB
ShmemHugePages:        0 kB
HugePages_Total:    2048
HugePages_Free:     2048
HugePages_Rsvd:        0
HugePages_Surp:        0
Hugepagesize:       2048 kB</literal_block>
            <paragraph>There are now 2048 2 MB huge pages totalling 4 GB of huge pages. These huge
                pages must be mounted. On most platforms, this happens automatically. To verify
                that the huge pages are mounted, run:</paragraph>
            <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve"># mount | grep huge
hugetlbfs on /dev/hugepages type hugetlbfs (rw)</literal_block>
            <paragraph>In this instance, the huge pages are mounted at <literal>/dev/hugepages</literal>. This mount
                point varies from platform to platform. If the above command did not return
                anything, the hugepages must be mounted manually. To mount the huge pages at
                <literal>/dev/hugepages</literal>, run:</paragraph>
            <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve"># mkdir -p /dev/hugepages
# mount -t hugetlbfs hugetlbfs /dev/hugepages</literal_block>
            <paragraph>There are many more ways to configure huge pages, including allocating huge
                pages at run time, specifying varying allocations for different huge page
                sizes, or allocating huge pages from memory affinitized to different NUMA
                nodes. For more information on configuring huge pages on Linux hosts, refer to
                the <reference name="Linux hugetlbfs guide" refuri="https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt">Linux hugetlbfs guide</reference>.</paragraph>
        </section>
        <section ids="customizing-instance-huge-pages-allocations" names="customizing\ instance\ huge\ pages\ allocations">
            <title>Customizing instance huge pages allocations</title>
            <important>
                <paragraph>The functionality described below is currently only supported by the
                    libvirt/KVM driver.</paragraph>
            </important>
            <important>
                <paragraph>For performance reasons, configuring huge pages for an instance will
                    implicitly result in a NUMA topology being configured for the instance.
                    Configuring a NUMA topology for an instance requires enablement of
                    <literal>NUMATopologyFilter</literal>. Refer to <reference internal="True" refuri="cpu-topologies"><inline classes="doc">CPU topologies</inline></reference> for more
                    information.</paragraph>
            </important>
            <paragraph>By default, an instance does not use huge pages for its underlying memory.
                However, huge pages can bring important or required performance improvements
                for some workloads. Huge pages must be requested explicitly through the use of
                flavor extra specs or image metadata. To request an instance use huge pages,
                run:</paragraph>
            <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve">$ openstack flavor set m1.large --property hw:mem_page_size=large</literal_block>
            <paragraph>Different platforms offer different huge page sizes. For example: x86-based
                platforms offer 2 MB and 1 GB huge page sizes. Specific huge page sizes can be
                also be requested, with or without a unit suffix. The unit suffix must be one
                of: Kb(it), Kib(it), Mb(it), Mib(it), Gb(it), Gib(it), Tb(it), Tib(it), KB,
                KiB, MB, MiB, GB, GiB, TB, TiB. Where a unit suffix is not provided, Kilobytes
                are assumed. To request an instance to use 2 MB huge pages, run one of:</paragraph>
            <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve">$ openstack flavor set m1.large --property hw:mem_page_size=2Mb</literal_block>
            <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve">$ openstack flavor set m1.large --property hw:mem_page_size=2048</literal_block>
            <paragraph>Enabling huge pages for an instance can have negative consequences for other
                instances by consuming limited huge pages resources. To explicitly request
                an instance use small pages, run:</paragraph>
            <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve">$ openstack flavor set m1.large --property hw:mem_page_size=small</literal_block>
            <note>
                <paragraph>Explicitly requesting any page size will still result in a NUMA topology
                    being applied to the instance, as described earlier in this document.</paragraph>
            </note>
            <paragraph>Finally, to leave the decision of huge or small pages to the compute driver,
                run:</paragraph>
            <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve">$ openstack flavor set m1.large --property hw:mem_page_size=any</literal_block>
            <paragraph>For more information about the syntax for <literal>hw:mem_page_size</literal>, refer to the
                <reference name="Flavors" refuri="https://docs.openstack.org/admin-guide/compute-flavors.html">Flavors</reference> guide.</paragraph>
            <paragraph>Applications are frequently packaged as images. For applications that require
                the IO performance improvements that huge pages provides, configure image
                metadata to ensure instances always request the specific page size regardless
                of flavor. To configure an image to use 1 GB huge pages, run:</paragraph>
            <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve">$ openstack image set [IMAGE_ID]  --property hw_mem_page_size=1GB</literal_block>
            <paragraph>If the flavor specifies a numerical page size or a page size of "small" the
                image is not allowed to specify a page size and if it does an exception will
                be raised. If the flavor specifies a page size of <literal>any</literal> or <literal>large</literal> then
                any page size specified in the image will be used. By setting a <literal>small</literal>
                page size in the flavor, administrators can prevent users requesting huge
                pages in flavors and impacting resource utilization. To configure this page
                size, run:</paragraph>
            <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve">$ openstack flavor set m1.large --property hw:mem_page_size=small</literal_block>
            <note>
                <paragraph>Explicitly requesting any page size will still result in a NUMA topology
                    being applied to the instance, as described earlier in this document.</paragraph>
            </note>
            <paragraph>For more information about image metadata, refer to the <reference name="Image metadata" refuri="https://docs.openstack.org/image-guide/image-metadata.html">Image metadata</reference>
                guide.</paragraph>
            <comment xml:space="preserve">Links</comment>
            <target ids="linux-thp-guide" names="linux\ thp\ guide" refuri="https://www.kernel.org/doc/Documentation/vm/transhuge.txt"></target>
            <target ids="linux-hugetlbfs-guide" names="linux\ hugetlbfs\ guide" refuri="https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt"></target>
            <target ids="flavors" names="flavors" refuri="https://docs.openstack.org/admin-guide/compute-flavors.html"></target>
            <target ids="image-metadata" names="image\ metadata" refuri="https://docs.openstack.org/image-guide/image-metadata.html"></target>
        </section>
    </section>
</document>
