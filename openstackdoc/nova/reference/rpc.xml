<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document source="/home/fbaumanis/openstack/soc8_test/openstack_repo/nova/doc/source/reference/rpc.rst">
    <comment xml:space="preserve">Copyright (c) 2010 Citrix Systems, Inc.
All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License"); you may
not use this file except in compliance with the License. You may obtain
a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations
under the License.</comment>
    <section ids="amqp-and-nova" names="amqp\ and\ nova">
        <title>AMQP and Nova</title>
        <paragraph>AMQP is the messaging technology chosen by the OpenStack cloud. The AMQP
            broker, either RabbitMQ or Qpid, sits between any two Nova components and
            allows them to communicate in a loosely coupled fashion. More precisely, Nova
            components (the compute fabric of OpenStack) use Remote Procedure Calls (RPC
            hereinafter) to communicate to one another; however such a paradigm is built
            atop the publish/subscribe paradigm so that the following benefits can be
            achieved:</paragraph>
        <bullet_list bullet="*">
            <list_item>
                <paragraph>Decoupling between client and servant (such as the client does not need to
                    know where the servant's reference is).</paragraph>
            </list_item>
            <list_item>
                <paragraph>Full a-synchronism between client and servant (such as the client does not
                    need the servant to run at the same time of the remote call).</paragraph>
            </list_item>
            <list_item>
                <paragraph>Random balancing of remote calls (such as if more servants are up and
                    running, one-way calls are transparently dispatched to the first available
                    servant).</paragraph>
            </list_item>
        </bullet_list>
        <paragraph>Nova uses direct, fanout, and topic-based exchanges. The architecture looks
            like the one depicted in the figure below:</paragraph>
        <image candidates="{'*': u'_static/images/rpc-arch.png'}" uri="_static/images/rpc-arch.png" width="60%"></image>
        <paragraph>Nova implements RPC (both request+response, and one-way, respectively nicknamed
            <literal>rpc.call</literal> and <literal>rpc.cast</literal>) over AMQP by providing an adapter class which
            take cares of marshaling and unmarshaling of messages into function calls. Each
            Nova service (for example Compute, Scheduler, etc.) create two queues at the
            initialization time, one which accepts messages with routing keys
            <literal>NODE-TYPE.NODE-ID</literal> (for example <literal>compute.hostname</literal>) and another, which
            accepts messages with routing keys as generic <literal>NODE-TYPE</literal> (for example
            <literal>compute</literal>). The former is used specifically when Nova-API needs to redirect
            commands to a specific node like <literal>euca-terminate instance</literal>. In this case,
            only the compute node whose host's hypervisor is running the virtual machine
            can kill the instance. The API acts as a consumer when RPC calls are
            request/response, otherwise it acts as a publisher only.</paragraph>
        <section ids="nova-rpc-mappings" names="nova\ rpc\ mappings">
            <title>Nova RPC Mappings</title>
            <paragraph>The figure below shows the internals of a message broker node (referred to as a
                RabbitMQ node in the diagrams) when a single instance is deployed and shared in
                an OpenStack cloud. Every Nova component connects to the message broker and,
                depending on its personality (for example a compute node or a network node),
                may use the queue either as an Invoker (such as API or Scheduler) or a Worker
                (such as Compute or Network). Invokers and Workers do not actually exist in the
                Nova object model, but we are going to use them as an abstraction for sake of
                clarity. An Invoker is a component that sends messages in the queuing system
                via two operations: 1) <literal>rpc.call</literal> and ii) <literal>rpc.cast</literal>; a Worker is a
                component that receives messages from the queuing system and reply accordingly
                to <literal>rpc.call</literal> operations.</paragraph>
            <paragraph>Figure 2 shows the following internal elements:</paragraph>
            <definition_list>
                <definition_list_item>
                    <term>Topic Publisher</term>
                    <definition>
                        <paragraph>A Topic Publisher comes to life when an <literal>rpc.call</literal> or an <literal>rpc.cast</literal>
                            operation is executed; this object is instantiated and used to push a message
                            to the queuing system. Every publisher connects always to the same
                            topic-based exchange; its life-cycle is limited to the message delivery.</paragraph>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term>Direct Consumer</term>
                    <definition>
                        <paragraph>A Direct Consumer comes to life if (and only if) an <literal>rpc.call</literal> operation is
                            executed; this object is instantiated and used to receive a response message
                            from the queuing system. Every consumer connects to a unique direct-based
                            exchange via a unique exclusive queue; its life-cycle is limited to the
                            message delivery; the exchange and queue identifiers are determined by a UUID
                            generator, and are marshaled in the message sent by the Topic Publisher (only
                            <literal>rpc.call</literal> operations).</paragraph>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term>Topic Consumer</term>
                    <definition>
                        <paragraph>A Topic Consumer comes to life as soon as a Worker is instantiated and exists
                            throughout its life-cycle; this object is used to receive messages from the
                            queue and it invokes the appropriate action as defined by the Worker role. A
                            Topic Consumer connects to the same topic-based exchange either via a shared
                            queue or via a unique exclusive queue. Every Worker has two topic consumers,
                            one that is addressed only during <literal>rpc.cast</literal> operations (and it connects to
                            a shared queue whose exchange key is <literal>topic</literal>) and the other that is
                            addressed only during <literal>rpc.call</literal> operations (and it connects to a unique
                            queue whose exchange key is <literal>topic.host</literal>).</paragraph>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term>Direct Publisher</term>
                    <definition>
                        <paragraph>A Direct Publisher comes to life only during <literal>rpc.call</literal> operations and it
                            is instantiated to return the message required by the request/response
                            operation. The object connects to a direct-based exchange whose identity is
                            dictated by the incoming message.</paragraph>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term>Topic Exchange</term>
                    <definition>
                        <paragraph>The Exchange is a routing table that exists in the context of a virtual host
                            (the multi-tenancy mechanism provided by Qpid or RabbitMQ); its type (such as
                            topic vs. direct) determines the routing policy; a message broker node will
                            have only one topic-based exchange for every topic in Nova.</paragraph>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term>Direct Exchange</term>
                    <definition>
                        <paragraph>This is a routing table that is created during <literal>rpc.call</literal> operations; there
                            are many instances of this kind of exchange throughout the life-cycle of a
                            message broker node, one for each <literal>rpc.call</literal> invoked.</paragraph>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term>Queue Element</term>
                    <definition>
                        <paragraph>A Queue is a message bucket. Messages are kept in the queue until a Consumer
                            (either Topic or Direct Consumer) connects to the queue and fetch it. Queues
                            can be shared or can be exclusive. Queues whose routing key is <literal>topic</literal> are
                            shared amongst Workers of the same personality.</paragraph>
                    </definition>
                </definition_list_item>
            </definition_list>
            <image candidates="{'*': u'_static/images/rpc-rabt.png'}" uri="_static/images/rpc-rabt.png" width="60%"></image>
        </section>
        <section ids="rpc-calls" names="rpc\ calls">
            <title>RPC Calls</title>
            <paragraph>The diagram below shows the message flow during an <literal>rpc.call</literal> operation:</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>A Topic Publisher is instantiated to send the message request to the queuing
                        system; immediately before the publishing operation, a Direct Consumer is
                        instantiated to wait for the response message.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Once the message is dispatched by the exchange, it is fetched by the Topic
                        Consumer dictated by the routing key (such as 'topic.host') and passed to
                        the Worker in charge of the task.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Once the task is completed, a Direct Publisher is allocated to send the
                        response message to the queuing system.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Once the message is dispatched by the exchange, it is fetched by the Direct
                        Consumer dictated by the routing key (such as <literal>msg_id</literal>) and passed to the
                        Invoker.</paragraph>
                </list_item>
            </enumerated_list>
            <image candidates="{'*': u'_static/images/rpc-flow-1.png'}" uri="_static/images/rpc-flow-1.png" width="60%"></image>
        </section>
        <section ids="rpc-casts" names="rpc\ casts">
            <title>RPC Casts</title>
            <paragraph>The diagram below shows the message flow during an <literal>rpc.cast</literal> operation:</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>A Topic Publisher is instantiated to send the message request to the queuing
                        system.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Once the message is dispatched by the exchange, it is fetched by the Topic
                        Consumer dictated by the routing key (such as 'topic') and passed to the
                        Worker in charge of the task.</paragraph>
                </list_item>
            </enumerated_list>
            <image candidates="{'*': u'_static/images/rpc-flow-2.png'}" uri="_static/images/rpc-flow-2.png" width="60%"></image>
        </section>
        <section ids="amqp-broker-load" names="amqp\ broker\ load">
            <title>AMQP Broker Load</title>
            <paragraph>At any given time the load of a message broker node running either Qpid or
                RabbitMQ is function of the following parameters:</paragraph>
            <definition_list>
                <definition_list_item>
                    <term>Throughput of API calls</term>
                    <definition>
                        <paragraph>The number of API calls (more precisely <literal>rpc.call</literal> ops) being served by the
                            OpenStack cloud dictates the number of direct-based exchanges, related queues
                            and direct consumers connected to them.</paragraph>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term>Number of Workers</term>
                    <definition>
                        <paragraph>There is one queue shared amongst workers with the same personality; however
                            there are as many exclusive queues as the number of workers; the number of
                            workers dictates also the number of routing keys within the topic-based
                            exchange, which is shared amongst all workers.</paragraph>
                    </definition>
                </definition_list_item>
            </definition_list>
            <paragraph>The figure below shows the status of a RabbitMQ node after Nova components'
                bootstrap in a test environment. Exchanges and queues being created by Nova
                components are:</paragraph>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph>Exchanges</paragraph>
                    <enumerated_list enumtype="arabic" prefix="" suffix=".">
                        <list_item>
                            <paragraph>nova (topic exchange)</paragraph>
                        </list_item>
                    </enumerated_list>
                </list_item>
                <list_item>
                    <paragraph>Queues</paragraph>
                    <enumerated_list enumtype="arabic" prefix="" suffix=".">
                        <list_item>
                            <paragraph><literal>compute.phantom</literal> (<literal>phantom</literal> is hostname)</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><literal>compute</literal></paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><literal>network.phantom</literal> (<literal>phantom</literal> is hostname)</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><literal>network</literal></paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><literal>scheduler.phantom</literal> (<literal>phantom</literal> is hostname)</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><literal>scheduler</literal></paragraph>
                        </list_item>
                    </enumerated_list>
                </list_item>
            </bullet_list>
            <image candidates="{'*': u'_static/images/rpc-state.png'}" uri="_static/images/rpc-state.png" width="60%"></image>
        </section>
        <section ids="rabbitmq-gotchas" names="rabbitmq\ gotchas">
            <title>RabbitMQ Gotchas</title>
            <paragraph>Nova uses Kombu to connect to the RabbitMQ environment. Kombu is a Python
                library that in turn uses AMQPLib, a library that implements the standard AMQP
                0.8 at the time of writing. When using Kombu, Invokers and Workers need the
                following parameters in order to instantiate a Connection object that connects
                to the RabbitMQ server (please note that most of the following material can be
                also found in the Kombu documentation; it has been summarized and revised here
                for sake of clarity):</paragraph>
            <definition_list>
                <definition_list_item>
                    <term><literal>hostname</literal></term>
                    <definition>
                        <paragraph>The hostname to the AMQP server.</paragraph>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term><literal>userid</literal></term>
                    <definition>
                        <paragraph>A valid username used to authenticate to the server.</paragraph>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term><literal>password</literal></term>
                    <definition>
                        <paragraph>The password used to authenticate to the server.</paragraph>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term><literal>virtual_host</literal></term>
                    <definition>
                        <paragraph>The name of the virtual host to work with. This virtual host must exist on
                            the server, and the user must have access to it. Default is "/".</paragraph>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term><literal>port</literal></term>
                    <definition>
                        <paragraph>The port of the AMQP server. Default is <literal>5672</literal> (amqp).</paragraph>
                    </definition>
                </definition_list_item>
            </definition_list>
            <paragraph>The following parameters are default:</paragraph>
            <definition_list>
                <definition_list_item>
                    <term><literal>insist</literal></term>
                    <definition>
                        <paragraph>Insist on connecting to a server. In a configuration with multiple
                            load-sharing servers, the Insist option tells the server that the client is
                            insisting on a connection to the specified server. Default is False.</paragraph>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term><literal>connect_timeout</literal></term>
                    <definition>
                        <paragraph>The timeout in seconds before the client gives up connecting to the server.
                            The default is no timeout.</paragraph>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term><literal>ssl</literal></term>
                    <definition>
                        <paragraph>Use SSL to connect to the server. The default is False.</paragraph>
                    </definition>
                </definition_list_item>
            </definition_list>
            <paragraph>More precisely Consumers need the following parameters:</paragraph>
            <definition_list>
                <definition_list_item>
                    <term><literal>connection</literal></term>
                    <definition>
                        <paragraph>The above mentioned Connection object.</paragraph>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term><literal>queue</literal></term>
                    <definition>
                        <paragraph>Name of the queue.</paragraph>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term><literal>exchange</literal></term>
                    <definition>
                        <paragraph>Name of the exchange the queue binds to.</paragraph>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term><literal>routing_key</literal></term>
                    <definition>
                        <paragraph>The interpretation of the routing key depends on the value of the
                            <literal>exchange_type</literal> attribute.</paragraph>
                        <definition_list>
                            <definition_list_item>
                                <term>Direct exchange</term>
                                <definition>
                                    <paragraph>If the routing key property of the message and the <literal>routing_key</literal> attribute of
                                        the queue are identical, then the message is forwarded to the queue.</paragraph>
                                </definition>
                            </definition_list_item>
                            <definition_list_item>
                                <term>Fanout exchange</term>
                                <definition>
                                    <paragraph>Messages are forwarded to the queues bound the exchange, even if the
                                        binding does not have a key.</paragraph>
                                </definition>
                            </definition_list_item>
                            <definition_list_item>
                                <term>Topic exchange</term>
                                <definition>
                                    <paragraph>If the routing key property of the message matches the routing key of the
                                        key according to a primitive pattern matching scheme, then the message is
                                        forwarded to the queue. The message routing key then consists of words
                                        separated by dots (<literal>.</literal>, like domain names), and two special characters
                                        are available; star (<literal>*</literal>) and hash (<literal>#</literal>). The star matches any word,
                                        and the hash matches zero or more words. For example <literal>.stock.#</literal> matches
                                        the routing keys <literal>usd.stock</literal> and <literal>eur.stock.db</literal> but not
                                        <literal>stock.nasdaq</literal>.</paragraph>
                                </definition>
                            </definition_list_item>
                        </definition_list>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term><literal>durable</literal></term>
                    <definition>
                        <paragraph>This flag determines the durability of both exchanges and queues; durable
                            exchanges and queues remain active when a RabbitMQ server restarts.
                            Non-durable exchanges/queues (transient exchanges/queues) are purged when a
                            server restarts. It is worth noting that AMQP specifies that durable queues
                            cannot bind to transient exchanges. Default is True.</paragraph>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term><literal>auto_delete</literal></term>
                    <definition>
                        <paragraph>If set, the exchange is deleted when all queues have finished using it.
                            Default is False.</paragraph>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term><literal>exclusive</literal></term>
                    <definition>
                        <paragraph>Exclusive queues (such as non-shared) may only be consumed from by the
                            current connection. When exclusive is on, this also implies <literal>auto_delete</literal>.
                            Default is False.</paragraph>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term><literal>exchange_type</literal></term>
                    <definition>
                        <paragraph>AMQP defines several default exchange types (routing algorithms) that covers
                            most of the common messaging use cases.</paragraph>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term><literal>auto_ack</literal></term>
                    <definition>
                        <paragraph>Acknowledgment is handled automatically once messages are received.  By
                            default <literal>auto_ack</literal> is set to False, and the receiver is required to manually
                            handle acknowledgment.</paragraph>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term><literal>no_ack</literal></term>
                    <definition>
                        <paragraph>It disable acknowledgment on the server-side. This is different from
                            <literal>auto_ack</literal> in that acknowledgment is turned off altogether. This
                            functionality increases performance but at the cost of reliability. Messages
                            can get lost if a client dies before it can deliver them to the application.</paragraph>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term><literal>auto_declare</literal></term>
                    <definition>
                        <paragraph>If this is True and the exchange name is set, the exchange will be
                            automatically declared at instantiation. Auto declare is on by default.</paragraph>
                    </definition>
                </definition_list_item>
            </definition_list>
            <paragraph>Publishers specify most the parameters of Consumers (such as they do not
                specify a queue name), but they can also specify the following:</paragraph>
            <definition_list>
                <definition_list_item>
                    <term><literal>delivery_mode</literal></term>
                    <definition>
                        <paragraph>The default delivery mode used for messages. The value is an integer. The
                            following delivery modes are supported by RabbitMQ:</paragraph>
                        <definition_list>
                            <definition_list_item>
                                <term><literal>1</literal> (transient)</term>
                                <definition>
                                    <paragraph>The message is transient. Which means it is stored in memory only, and is
                                        lost if the server dies or restarts.</paragraph>
                                </definition>
                            </definition_list_item>
                            <definition_list_item>
                                <term><literal>2</literal> (persistent)</term>
                                <definition>
                                    <paragraph>The message is persistent. Which means the message is stored both
                                        in-memory, and on disk, and therefore preserved if the server dies or
                                        restarts.</paragraph>
                                </definition>
                            </definition_list_item>
                        </definition_list>
                    </definition>
                </definition_list_item>
            </definition_list>
            <paragraph>The default value is <literal>2</literal> (persistent). During a send operation, Publishers
                can override the delivery mode of messages so that, for example, transient
                messages can be sent over a durable queue.</paragraph>
        </section>
    </section>
</document>
