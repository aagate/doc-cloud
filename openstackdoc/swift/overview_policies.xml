<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.14 -->
<document source="/home/fbaumanis/openstack/soc8_test/openstack_repo/swift/doc/source/overview_policies.rst">
    <section ids="storage-policies" names="storage\ policies">
        <title>Storage Policies</title>
        <paragraph>Storage Policies allow for some level of segmenting the cluster for various
            purposes through the creation of multiple object rings. The Storage Policies
            feature is implemented throughout the entire code base so it is an important
            concept in understanding Swift architecture.</paragraph>
        <paragraph>As described in <reference internal="True" refuri="overview_ring"><inline classes="doc">The Rings</inline></reference>, Swift uses modified hashing rings to
            determine where data should reside in the cluster. There is a separate ring for
            account databases, container databases, and there is also one object ring per
            storage policy.  Each object ring behaves exactly the same way and is maintained
            in the same manner, but with policies, different devices can belong to different
            rings. By supporting multiple object rings, Swift allows the application and/or
            deployer to essentially segregate the object storage within a single cluster.
            There are many reasons why this might be desirable:</paragraph>
        <bullet_list bullet="*">
            <list_item>
                <paragraph>Different levels of durability:  If a provider wants to offer, for example,
                    2x replication and 3x replication but doesn’t want to maintain 2 separate
                    clusters, they would setup a 2x and a 3x replication policy and assign the
                    nodes to their respective rings. Furthermore, if a provider wanted to offer a
                    cold storage tier, they could create an erasure coded policy.</paragraph>
            </list_item>
            <list_item>
                <paragraph>Performance:  Just as SSDs can be used as the exclusive members of an account
                    or database ring, an SSD-only object ring can be created as well and used to
                    implement a low-latency/high performance policy.</paragraph>
            </list_item>
            <list_item>
                <paragraph>Collecting nodes into group:  Different object rings may have different
                    physical servers so that objects in specific storage policies are always
                    placed in a particular data center or geography.</paragraph>
            </list_item>
            <list_item>
                <paragraph>Different Storage implementations:  Another example would be to collect
                    together a set of nodes that use a different Diskfile (e.g., Kinetic,
                    GlusterFS) and use a policy to direct traffic just to those nodes.</paragraph>
            </list_item>
            <list_item>
                <paragraph>Different read and write affinity settings: proxy-servers can be configured
                    to use different read and write affinity options for each policy. See
                    <reference internal="True" refuri="deployment_guide#proxy-server-per-policy-config"><inline classes="std std-ref">Per policy configuration</inline></reference> for more details.</paragraph>
            </list_item>
        </bullet_list>
        <note>
            <paragraph>Today, Swift supports two different policy types: Replication and Erasure
                Code. See <reference internal="True" refuri="overview_erasure_code"><inline classes="doc">Erasure Code Support</inline></reference> for details.</paragraph>
            <paragraph>Also note that Diskfile refers to backend object storage plug-in
                architecture. See <reference internal="True" refuri="development_ondisk_backends"><inline classes="doc">Pluggable On-Disk Back-end APIs</inline></reference> for details.</paragraph>
        </note>
        <section ids="containers-and-policies" names="containers\ and\ policies">
            <title>Containers and Policies</title>
            <paragraph>Policies are implemented at the container level.  There are many advantages to
                this approach, not the least of which is how easy it makes life on
                applications that want to take advantage of them.  It also ensures that
                Storage Policies remain a core feature of Swift independent of the auth
                implementation.  Policies were not implemented at the account/auth layer
                because it would require changes to all auth systems in use by Swift
                deployers.  Each container has a new special immutable metadata element called
                the storage policy index.  Note that internally, Swift relies on policy
                indexes and not policy names.  Policy names exist for human readability and
                translation is managed in the proxy.  When a container is created, one new
                optional header is supported to specify the policy name. If no name is
                specified, the default policy is used (and if no other policies defined,
                Policy-0 is considered the default).  We will be covering the difference
                between default and Policy-0 in the next section.</paragraph>
            <paragraph>Policies are assigned when a container is created.  Once a container has been
                assigned a policy, it cannot be changed (unless it is deleted/recreated).  The
                implications on data placement/movement for large datasets would make this a
                task best left for applications to perform. Therefore, if a container has an
                existing policy of, for example 3x replication, and one wanted to migrate that
                data to an Erasure Code policy, the application would create another container
                specifying the other policy parameters and then simply move the data from one
                container to the other.  Policies apply on a per container basis allowing for
                minimal application awareness; once a container has been created with a specific
                policy, all objects stored in it will be done so in accordance with that policy.
                If a container with a specific name is deleted (requires the container be empty)
                a new container may be created with the same name without any restriction on
                storage policy enforced by the deleted container which previously shared the
                same name.</paragraph>
            <paragraph>Containers have a many-to-one relationship with policies meaning that any number
                of containers can share one policy.  There is no limit to how many containers
                can use a specific policy.</paragraph>
            <paragraph>The notion of associating a ring with a container introduces an interesting
                scenario: What would happen if 2 containers of the same name were created with
                different Storage Policies on either side of a network outage at the same time?
                Furthermore, what would happen if objects were placed in those containers, a
                whole bunch of them, and then later the network outage was restored?  Well,
                without special care it would be a big problem as an application could end up
                using the wrong ring to try and find an object.  Luckily there is a solution for
                this problem, a daemon known as the Container Reconciler works tirelessly to
                identify and rectify this potential scenario.</paragraph>
        </section>
        <section ids="container-reconciler" names="container\ reconciler">
            <title>Container Reconciler</title>
            <paragraph>Because atomicity of container creation cannot be enforced in a
                distributed eventually consistent system, object writes into the wrong
                storage policy must be eventually merged into the correct storage policy
                by an asynchronous daemon.  Recovery from object writes during a network
                partition which resulted in a split brain container created with
                different storage policies are handled by the
                <title_reference>swift-container-reconciler</title_reference> daemon.</paragraph>
            <paragraph>The container reconciler works off a queue similar to the
                object-expirer.  The queue is populated during container-replication.
                It is never considered incorrect to enqueue an object to be evaluated by
                the container-reconciler because if there is nothing wrong with the location
                of the object the reconciler will simply dequeue it.  The
                container-reconciler queue is an indexed log for the real location of an
                object for which a discrepancy in the storage policy of the container was
                discovered.</paragraph>
            <paragraph>To determine the correct storage policy of a container, it is necessary
                to update the status_changed_at field in the container_stat table when a
                container changes status from deleted to re-created.  This transaction
                log allows the container-replicator to update the correct storage policy
                both when replicating a container and handling REPLICATE requests.</paragraph>
            <paragraph>Because each object write is a separate distributed transaction it is
                not possible to determine the correctness of the storage policy for each
                object write with respect to the entire transaction log at a given
                container database.  As such, container databases will always record the
                object write regardless of the storage policy on a per object row basis.
                Object byte and count stats are tracked per storage policy in each
                container and reconciled using normal object row merge semantics.</paragraph>
            <paragraph>The object rows are ensured to be fully durable during replication using
                the normal container replication.  After the container
                replicator pushes its object rows to available primary nodes any
                misplaced object rows are bulk loaded into containers based off the
                object timestamp under the <literal>.misplaced_objects</literal> system account.  The
                rows are initially written to a handoff container on the local node, and
                at the end of the replication pass the <literal>.misplaced_objects</literal> containers are
                replicated to the correct primary nodes.</paragraph>
            <paragraph>The container-reconciler processes the <literal>.misplaced_objects</literal> containers in
                descending order and reaps its containers as the objects represented by
                the rows are successfully reconciled.  The container-reconciler will
                always validate the correct storage policy for enqueued objects using
                direct container HEAD requests which are accelerated via caching.</paragraph>
            <paragraph>Because failure of individual storage nodes in aggregate is assumed to
                be common at scale, the container-reconciler will make forward progress
                with a simple quorum majority.  During a combination of failures and
                rebalances it is possible that a quorum could provide an incomplete
                record of the correct storage policy - so an object write may have to be
                applied more than once.  Because storage nodes and container databases
                will not process writes with an <literal>X-Timestamp</literal> less than or equal to
                their existing record when objects writes are re-applied their timestamp
                is slightly incremented.  In order for this increment to be applied
                transparently to the client a second vector of time has been added to
                Swift for internal use.  See <reference internal="True" reftitle="swift.common.utils.Timestamp" refuri="misc#swift.common.utils.Timestamp"><literal classes="xref py py-class">Timestamp</literal></reference>.</paragraph>
            <paragraph>As the reconciler applies object writes to the correct storage policy it
                cleans up writes which no longer apply to the incorrect storage policy
                and removes the rows from the <literal>.misplaced_objects</literal> containers.  After all
                rows have been successfully processed it sleeps and will periodically
                check for newly enqueued rows to be discovered during container
                replication.</paragraph>
            <target refid="default-policy"></target>
        </section>
        <section ids="default-versus-policy-0 default-policy" names="default\ versus\ 'policy-0' default-policy">
            <title>Default versus ‘Policy-0’</title>
            <paragraph>Storage Policies is a versatile feature intended to support both new and
                pre-existing clusters with the same level of flexibility.  For that reason, we
                introduce the <literal>Policy-0</literal> concept which is not the same as the “default”
                policy.  As you will see when we begin to configure policies, each policy has
                a single name and an arbitrary number of aliases (human friendly,
                configurable) as well as an index (or simply policy number). Swift reserves
                index 0 to map to the object ring that’s present in all installations
                (e.g., <literal>/etc/swift/object.ring.gz</literal>). You can name this policy anything you
                like, and if no policies are defined it will report itself as <literal>Policy-0</literal>,
                however you cannot change the index as there must always be a policy with
                index 0.</paragraph>
            <paragraph>Another important concept is the default policy which can be any policy
                in the cluster.  The default policy is the policy that is automatically
                chosen when a container creation request is sent without a storage
                policy being specified. <reference internal="True" refid="configure-policy"><inline classes="std std-ref">Configuring Policies</inline></reference> describes how to set the
                default policy.  The difference from <literal>Policy-0</literal> is subtle but
                extremely important.  <literal>Policy-0</literal> is what is used by Swift when
                accessing pre-storage-policy containers which won’t have a policy - in
                this case we would not use the default as it might not have the same
                policy as legacy containers.  When no other policies are defined, Swift
                will always choose <literal>Policy-0</literal> as the default.</paragraph>
            <paragraph>In other words, default means “create using this policy if nothing else is
                specified” and <literal>Policy-0</literal> means “use the legacy policy if a container doesn’t
                have one” which really means use <literal>object.ring.gz</literal> for lookups.</paragraph>
            <note>
                <paragraph>With the Storage Policy based code, it’s not possible to create a
                    container that doesn’t have a policy.  If nothing is provided, Swift will
                    still select the default and assign it to the container.  For containers
                    created before Storage Policies were introduced, the legacy Policy-0 will
                    be used.</paragraph>
            </note>
            <target refid="deprecate-policy"></target>
        </section>
        <section ids="deprecating-policies deprecate-policy" names="deprecating\ policies deprecate-policy">
            <title>Deprecating Policies</title>
            <paragraph>There will be times when a policy is no longer desired; however simply
                deleting the policy and associated rings would be problematic for existing
                data.  In order to ensure that resources are not orphaned in the cluster (left
                on disk but no longer accessible) and to provide proper messaging to
                applications when a policy needs to be retired, the notion of deprecation is
                used.  <reference internal="True" refid="configure-policy"><inline classes="std std-ref">Configuring Policies</inline></reference> describes how to deprecate a policy.</paragraph>
            <paragraph>Swift’s behavior with deprecated policies is as follows:</paragraph>
            <block_quote>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>The deprecated policy will not appear in /info</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>PUT/GET/DELETE/POST/HEAD are still allowed on the pre-existing containers
                            created with a deprecated policy</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Clients will get an ‘‘400 Bad Request’’ error when trying to create a new
                            container using the deprecated policy</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Clients still have access to policy statistics via HEAD on pre-existing
                            containers</paragraph>
                    </list_item>
                </bullet_list>
            </block_quote>
            <note>
                <paragraph>A policy cannot be both the default and deprecated.  If you deprecate the
                    default policy, you must specify a new default.</paragraph>
            </note>
            <paragraph>You can also use the deprecated feature to rollout new policies.  If you
                want to test a new storage policy before making it generally available
                you could deprecate the policy when you initially roll it the new
                configuration and rings to all nodes.  Being deprecated will render it
                innate and unable to be used.  To test it you will need to create a
                container with that storage policy; which will require a single proxy
                instance (or a set of proxy-servers which are only internally
                accessible) that has been one-off configured with the new policy NOT
                marked deprecated.  Once the container has been created with the new
                storage policy any client authorized to use that container will be able
                to add and access data stored in that container in the new storage
                policy.  When satisfied you can roll out a new <literal>swift.conf</literal> which does
                not mark the policy as deprecated to all nodes.</paragraph>
            <target refid="configure-policy"></target>
        </section>
        <section ids="configuring-policies configure-policy" names="configuring\ policies configure-policy">
            <title>Configuring Policies</title>
            <note>
                <paragraph>See <reference internal="True" refuri="policies_saio"><inline classes="doc">Adding Storage Policies to an Existing SAIO</inline></reference> for a step by step guide on adding a policy to the
                    SAIO setup.</paragraph>
            </note>
            <paragraph>It is important that the deployer have a solid understanding of the semantics
                for configuring policies.  Configuring a policy is a three-step process:</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>Edit your <literal>/etc/swift/swift.conf</literal> file to define your new policy.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Create the corresponding policy object ring file.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>(Optional) Create policy-specific proxy-server configuration settings.</paragraph>
                </list_item>
            </enumerated_list>
            <section ids="defining-a-policy" names="defining\ a\ policy">
                <title>Defining a policy</title>
                <paragraph>Each policy is defined by a section in the <literal>/etc/swift/swift.conf</literal> file. The
                    section name must be of the form <literal>[storage-policy:&lt;N&gt;]</literal> where <literal>&lt;N&gt;</literal> is the
                    policy index. There’s no reason other than readability that policy indexes be
                    sequential but the following rules are enforced:</paragraph>
                <block_quote>
                    <bullet_list bullet="*">
                        <list_item>
                            <paragraph>If a policy with index <literal>0</literal> is not declared and no other policies are
                                defined, Swift will create a default policy with index <literal>0</literal>.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>The policy index must be a non-negative integer.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>Policy indexes must be unique.</paragraph>
                        </list_item>
                    </bullet_list>
                </block_quote>
                <warning>
                    <paragraph>The index of a policy should never be changed once a policy has been
                        created and used. Changing a policy index may cause loss of access to data.</paragraph>
                </warning>
                <paragraph>Each policy section contains the following options:</paragraph>
                <block_quote>
                    <bullet_list bullet="*">
                        <list_item>
                            <definition_list>
                                <definition_list_item>
                                    <term><literal>name = &lt;policy_name&gt;</literal> (required)</term>
                                    <definition>
                                        <bullet_list bullet="-">
                                            <list_item>
                                                <paragraph>The primary name of the policy.</paragraph>
                                            </list_item>
                                            <list_item>
                                                <paragraph>Policy names are case insensitive.</paragraph>
                                            </list_item>
                                            <list_item>
                                                <paragraph>Policy names must contain only letters, digits or a dash.</paragraph>
                                            </list_item>
                                            <list_item>
                                                <paragraph>Policy names must be unique.</paragraph>
                                            </list_item>
                                            <list_item>
                                                <paragraph>Policy names can be changed.</paragraph>
                                            </list_item>
                                            <list_item>
                                                <paragraph>The name <literal>Policy-0</literal> can only be used for the policy with
                                                    index <literal>0</literal>.</paragraph>
                                            </list_item>
                                        </bullet_list>
                                    </definition>
                                </definition_list_item>
                            </definition_list>
                        </list_item>
                        <list_item>
                            <definition_list>
                                <definition_list_item>
                                    <term><literal>alias = &lt;policy_name&gt;[, &lt;policy_name&gt;, ...]</literal> (optional)</term>
                                    <definition>
                                        <bullet_list bullet="-">
                                            <list_item>
                                                <paragraph>A comma-separated list of alternative names for the policy.</paragraph>
                                            </list_item>
                                            <list_item>
                                                <paragraph>The default value is an empty list (i.e. no aliases).</paragraph>
                                            </list_item>
                                            <list_item>
                                                <paragraph>All alias names must follow the rules for the <literal>name</literal> option.</paragraph>
                                            </list_item>
                                            <list_item>
                                                <paragraph>Aliases can be added to and removed from the list.</paragraph>
                                            </list_item>
                                            <list_item>
                                                <paragraph>Aliases can be useful to retain support for old primary names if the
                                                    primary name is changed.</paragraph>
                                            </list_item>
                                        </bullet_list>
                                    </definition>
                                </definition_list_item>
                            </definition_list>
                        </list_item>
                        <list_item>
                            <definition_list>
                                <definition_list_item>
                                    <term><literal>default = [true|false]</literal> (optional)</term>
                                    <definition>
                                        <bullet_list bullet="-">
                                            <list_item>
                                                <paragraph>If <literal>true</literal> then this policy will be used when the client does not
                                                    specify a policy.</paragraph>
                                            </list_item>
                                            <list_item>
                                                <paragraph>The default value is <literal>false</literal>.</paragraph>
                                            </list_item>
                                            <list_item>
                                                <paragraph>The default policy can be changed at any time, by setting
                                                    <literal>default = true</literal> in the desired policy section.</paragraph>
                                            </list_item>
                                            <list_item>
                                                <paragraph>If no policy is declared as the default and no other policies are
                                                    defined, the policy with index <literal>0</literal> is set as the default;</paragraph>
                                            </list_item>
                                            <list_item>
                                                <paragraph>Otherwise, exactly one policy must be declared default.</paragraph>
                                            </list_item>
                                            <list_item>
                                                <paragraph>Deprecated policies cannot be declared the default.</paragraph>
                                            </list_item>
                                            <list_item>
                                                <paragraph>See <reference internal="True" refid="default-policy"><inline classes="std std-ref">Default versus ‘Policy-0’</inline></reference> for more information.</paragraph>
                                            </list_item>
                                        </bullet_list>
                                    </definition>
                                </definition_list_item>
                            </definition_list>
                        </list_item>
                        <list_item>
                            <definition_list>
                                <definition_list_item>
                                    <term><literal>deprecated = [true|false]</literal> (optional)</term>
                                    <definition>
                                        <bullet_list bullet="-">
                                            <list_item>
                                                <paragraph>If <literal>true</literal> then new containers cannot be created using this policy.</paragraph>
                                            </list_item>
                                            <list_item>
                                                <paragraph>The default value is <literal>false</literal>.</paragraph>
                                            </list_item>
                                            <list_item>
                                                <paragraph>Any policy may be deprecated by adding the <literal>deprecated</literal> option to
                                                    the desired policy section. However, a deprecated policy may not also
                                                    be declared the default. Therefore, since there must always be a
                                                    default policy, there must also always be at least one policy which
                                                    is not deprecated.</paragraph>
                                            </list_item>
                                            <list_item>
                                                <paragraph>See <reference internal="True" refid="deprecate-policy"><inline classes="std std-ref">Deprecating Policies</inline></reference> for more information.</paragraph>
                                            </list_item>
                                        </bullet_list>
                                    </definition>
                                </definition_list_item>
                            </definition_list>
                        </list_item>
                        <list_item>
                            <definition_list>
                                <definition_list_item>
                                    <term><literal>policy_type = [replication|erasure_coding]</literal> (optional)</term>
                                    <definition>
                                        <bullet_list bullet="-">
                                            <list_item>
                                                <paragraph>The option <literal>policy_type</literal> is used to distinguish between different
                                                    policy types.</paragraph>
                                            </list_item>
                                            <list_item>
                                                <paragraph>The default value is <literal>replication</literal>.</paragraph>
                                            </list_item>
                                            <list_item>
                                                <paragraph>When defining an EC policy use the value <literal>erasure_coding</literal>.</paragraph>
                                            </list_item>
                                        </bullet_list>
                                    </definition>
                                </definition_list_item>
                            </definition_list>
                        </list_item>
                    </bullet_list>
                </block_quote>
                <paragraph>The EC policy type has additional required options. See
                    <reference internal="True" refuri="overview_erasure_code#using-ec-policy"><inline classes="std std-ref">Using an Erasure Code Policy</inline></reference> for details.</paragraph>
                <paragraph>The following is an example of a properly configured <literal>swift.conf</literal> file. See
                    <reference internal="True" refuri="policies_saio"><inline classes="doc">Adding Storage Policies to an Existing SAIO</inline></reference> for full instructions on setting up an all-in-one with
                    this example configuration.:</paragraph>
                <literal_block xml:space="preserve">[swift-hash]
# random unique strings that can never change (DO NOT LOSE)
# Use only printable chars (python -c "import string; print(string.printable)")
swift_hash_path_prefix = changeme
swift_hash_path_suffix = changeme

[storage-policy:0]
name = gold
aliases = yellow, orange
policy_type = replication
default = yes

[storage-policy:1]
name = silver
policy_type = replication
deprecated = yes</literal_block>
            </section>
            <section ids="creating-a-ring" names="creating\ a\ ring">
                <title>Creating a ring</title>
                <paragraph>Once <literal>swift.conf</literal> is configured for a new policy, a new ring must be created.
                    The ring tools are not policy name aware so it’s critical that the correct
                    policy index be used when creating the new policy’s ring file. Additional
                    object rings are created using <literal>swift-ring-builder</literal> in the same manner as the
                    legacy ring except that <literal>-N</literal> is appended after the word <literal>object</literal> in the
                    builder file name, where <literal>N</literal> matches the policy index used in <literal>swift.conf</literal>.
                    So, to create the ring for policy index <literal>1</literal>:</paragraph>
                <literal_block xml:space="preserve">swift-ring-builder object-1.builder create 10 3 1</literal_block>
                <paragraph>Continue to use the same naming convention when using <literal>swift-ring-builder</literal> to
                    add devices, rebalance etc. This naming convention is also used in the pattern
                    for per-policy storage node data directories.</paragraph>
                <note>
                    <paragraph>The same drives can indeed be used for multiple policies and the details
                        of how that’s managed on disk will be covered in a later section, it’s
                        important to understand the implications of such a configuration before
                        setting one up.  Make sure it’s really what you want to do, in many cases
                        it will be, but in others maybe not.</paragraph>
                </note>
            </section>
            <section ids="proxy-server-configuration-optional" names="proxy\ server\ configuration\ (optional)">
                <title>Proxy server configuration (optional)</title>
                <paragraph>The <reference internal="True" refuri="proxy#proxy-server"><inline classes="std std-ref">Proxy Server</inline></reference> configuration options related to read and write
                    affinity may optionally be overridden for individual storage policies. See
                    <reference internal="True" refuri="deployment_guide#proxy-server-per-policy-config"><inline classes="std std-ref">Per policy configuration</inline></reference> for more details.</paragraph>
            </section>
        </section>
        <section ids="using-policies" names="using\ policies">
            <title>Using Policies</title>
            <paragraph>Using policies is very simple - a policy is only specified when a container is
                initially created.  There are no other API changes.  Creating a container can
                be done without any special policy information:</paragraph>
            <literal_block xml:space="preserve">curl -v -X PUT -H 'X-Auth-Token: &lt;your auth token&gt;' \
    http://127.0.0.1:8080/v1/AUTH_test/myCont0</literal_block>
            <paragraph>Which will result in a container created that is associated with the
                policy name ‘gold’ assuming we’re using the swift.conf example from
                above.  It would use ‘gold’ because it was specified as the default.
                Now, when we put an object into this container, it will get placed on
                nodes that are part of the ring we created for policy ‘gold’.</paragraph>
            <paragraph>If we wanted to explicitly state that we wanted policy ‘gold’ the command
                would simply need to include a new header as shown below:</paragraph>
            <literal_block xml:space="preserve">curl -v -X PUT -H 'X-Auth-Token: &lt;your auth token&gt;' \
    -H 'X-Storage-Policy: gold' http://127.0.0.1:8080/v1/AUTH_test/myCont0</literal_block>
            <paragraph>And that’s it!  The application does not need to specify the policy name ever
                again.  There are some illegal operations however:</paragraph>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph>If an invalid (typo, non-existent) policy is specified: 400 Bad Request</paragraph>
                </list_item>
                <list_item>
                    <paragraph>if you try to change the policy either via PUT or POST: 409 Conflict</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>If you’d like to see how the storage in the cluster is being used, simply HEAD
                the account and you’ll see not only the cumulative numbers, as before, but
                per policy statistics as well.  In the example below there’s 3 objects total
                with two of them in policy ‘gold’ and one in policy ‘silver’:</paragraph>
            <literal_block xml:space="preserve">curl -i -X HEAD -H 'X-Auth-Token: &lt;your auth token&gt;' \
    http://127.0.0.1:8080/v1/AUTH_test</literal_block>
            <paragraph>and your results will include (some output removed for readability):</paragraph>
            <literal_block xml:space="preserve">X-Account-Container-Count: 3
X-Account-Object-Count: 3
X-Account-Bytes-Used: 21
X-Storage-Policy-Gold-Object-Count: 2
X-Storage-Policy-Gold-Bytes-Used: 14
X-Storage-Policy-Silver-Object-Count: 1
X-Storage-Policy-Silver-Bytes-Used: 7</literal_block>
        </section>
        <section ids="under-the-hood" names="under\ the\ hood">
            <title>Under the Hood</title>
            <paragraph>Now that we’ve explained a little about what Policies are and how to
                configure/use them, let’s explore how Storage Policies fit in at the
                nuts-n-bolts level.</paragraph>
            <section ids="parsing-and-configuring" names="parsing\ and\ configuring">
                <title>Parsing and Configuring</title>
                <paragraph>The module, <reference internal="True" refuri="misc#storage-policy"><inline classes="std std-ref">Storage Policy</inline></reference>, is responsible for parsing the
                    <literal>swift.conf</literal> file, validating the input, and creating a global collection of
                    configured policies via class <reference internal="True" reftitle="swift.common.storage_policy.StoragePolicyCollection" refuri="misc#swift.common.storage_policy.StoragePolicyCollection"><literal classes="xref py py-class">StoragePolicyCollection</literal></reference>.  This
                    collection is made up of policies of class <reference internal="True" reftitle="swift.common.storage_policy.StoragePolicy" refuri="misc#swift.common.storage_policy.StoragePolicy"><literal classes="xref py py-class">StoragePolicy</literal></reference>. The
                    collection class includes handy functions for getting to a policy either by
                    name or by index , getting info about the policies, etc. There’s also one
                    very important function, <reference internal="True" reftitle="swift.common.storage_policy.StoragePolicyCollection.get_object_ring" refuri="misc#swift.common.storage_policy.StoragePolicyCollection.get_object_ring"><literal classes="xref py py-meth">get_object_ring()</literal></reference>.
                    Object rings are members of the <reference internal="True" reftitle="swift.common.storage_policy.StoragePolicy" refuri="misc#swift.common.storage_policy.StoragePolicy"><literal classes="xref py py-class">StoragePolicy</literal></reference> class and are
                    actually not instantiated until the <literal classes="xref py py-meth">load_ring()</literal>
                    method is called.  Any caller anywhere in the code base that needs to access
                    an object ring must use the <literal classes="xref py py-data">POLICIES</literal> global singleton to access the
                    <reference internal="True" reftitle="swift.common.storage_policy.StoragePolicyCollection.get_object_ring" refuri="misc#swift.common.storage_policy.StoragePolicyCollection.get_object_ring"><literal classes="xref py py-meth">get_object_ring()</literal></reference> function and provide the
                    policy index which will call <literal classes="xref py py-meth">load_ring()</literal> if
                    needed; however, when starting request handling services such as the
                    <reference internal="True" refuri="proxy#proxy-server"><inline classes="std std-ref">Proxy Server</inline></reference> rings are proactively loaded to provide moderate
                    protection against a mis-configuration resulting in a run time error.  The
                    global is instantiated when Swift starts and provides a mechanism to patch
                    policies for the test code.</paragraph>
            </section>
            <section ids="middleware" names="middleware">
                <title>Middleware</title>
                <paragraph>Middleware can take advantage of policies through the <literal classes="xref py py-data">POLICIES</literal> global
                    and by importing <reference internal="True" reftitle="swift.proxy.controllers.base.get_container_info" refuri="proxy#swift.proxy.controllers.base.get_container_info"><literal classes="xref py py-func">get_container_info()</literal></reference> to gain access to the policy index
                    associated with the container in question.  From the index it can then use the
                    <literal classes="xref py py-data">POLICIES</literal> singleton to grab the right ring.  For example,
                    <reference internal="True" refuri="middleware#list-endpoints"><inline classes="std std-ref">List Endpoints</inline></reference> is policy aware using the means just described. Another
                    example is <reference internal="True" refuri="middleware#recon"><inline classes="std std-ref">Recon</inline></reference> which will report the md5 sums for all of the rings.</paragraph>
            </section>
            <section ids="proxy-server" names="proxy\ server">
                <title>Proxy Server</title>
                <paragraph>The <reference internal="True" refuri="proxy#proxy-server"><inline classes="std std-ref">Proxy Server</inline></reference> module’s role in Storage Policies is essentially to make
                    sure the correct ring is used as its member element.  Before policies, the one
                    object ring would be instantiated when the <reference internal="True" reftitle="swift.proxy.server.Application" refuri="proxy#swift.proxy.server.Application"><literal classes="xref py py-class">Application</literal></reference> class was
                    instantiated and could be overridden by test code via init parameter.  With
                    policies, however, there is no init parameter and the <reference internal="True" reftitle="swift.proxy.server.Application" refuri="proxy#swift.proxy.server.Application"><literal classes="xref py py-class">Application</literal></reference>
                    class instead depends on the <literal classes="xref py py-data">POLICIES</literal> global singleton to retrieve the
                    ring which is instantiated the first time it’s needed.  So, instead of an object
                    ring member of the <reference internal="True" reftitle="swift.proxy.server.Application" refuri="proxy#swift.proxy.server.Application"><literal classes="xref py py-class">Application</literal></reference> class, there is an accessor function,
                    <reference internal="True" reftitle="swift.proxy.server.Application.get_object_ring" refuri="proxy#swift.proxy.server.Application.get_object_ring"><literal classes="xref py py-meth">get_object_ring()</literal></reference>, that gets the ring from
                    <literal classes="xref py py-data">POLICIES</literal>.</paragraph>
                <paragraph>In general, when any module running on the proxy requires an object ring, it
                    does so via first getting the policy index from the cached container info.  The
                    exception is during container creation where it uses the policy name from the
                    request header to look up policy index from the <literal classes="xref py py-data">POLICIES</literal> global.  Once
                    the proxy has determined the policy index, it can use the
                    <reference internal="True" reftitle="swift.proxy.server.Application.get_object_ring" refuri="proxy#swift.proxy.server.Application.get_object_ring"><literal classes="xref py py-meth">get_object_ring()</literal></reference> method described earlier to gain access to
                    the correct ring.  It then has the responsibility of passing the index
                    information, not the policy name, on to the back-end servers via the header <literal>X
-Backend-Storage-Policy-Index</literal>. Going the other way, the proxy also strips the
                    index out of headers that go back to clients, and makes sure they only see the
                    friendly policy names.</paragraph>
            </section>
            <section ids="on-disk-storage" names="on\ disk\ storage">
                <title>On Disk Storage</title>
                <paragraph>Policies each have their own directories on the back-end servers and are
                    identified by their storage policy indexes.  Organizing the back-end directory
                    structures by policy index helps keep track of things and also allows for
                    sharing of disks between policies which may or may not make sense depending on
                    the needs of the provider.  More on this later, but for now be aware of the
                    following directory naming convention:</paragraph>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph><literal>/objects</literal> maps to objects associated with Policy-0</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>/objects-N</literal> maps to storage policy index #N</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>/async_pending</literal> maps to async pending update for Policy-0</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>/async_pending-N</literal> maps to async pending update for storage policy index #N</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>/tmp</literal> maps to the DiskFile temporary directory for Policy-0</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>/tmp-N</literal> maps to the DiskFile temporary directory for policy index #N</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>/quarantined/objects</literal> maps to the quarantine directory for Policy-0</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>/quarantined/objects-N</literal> maps to the quarantine directory for policy index #N</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>Note that these directory names are actually owned by the specific Diskfile
                    implementation, the names shown above are used by the default Diskfile.</paragraph>
            </section>
            <section ids="object-server" names="object\ server">
                <title>Object Server</title>
                <paragraph>The <reference internal="True" refuri="object#object-server"><inline classes="std std-ref">Object Server</inline></reference> is not involved with selecting the storage policy
                    placement directly.  However, because of how back-end directory structures are
                    setup for policies, as described earlier, the object server modules do play a
                    role.  When the object server gets a <literal classes="xref py py-class">Diskfile</literal>, it passes in the
                    policy index and leaves the actual directory naming/structure mechanisms to
                    <literal classes="xref py py-class">Diskfile</literal>.  By passing in the index, the instance of
                    <literal classes="xref py py-class">Diskfile</literal> being used will assure that data is properly located in the
                    tree based on its policy.</paragraph>
                <paragraph>For the same reason, the <reference internal="True" refuri="object#object-updater"><inline classes="std std-ref">Object Updater</inline></reference> also is policy aware.  As
                    previously described, different policies use different async pending directories
                    so the updater needs to know how to scan them appropriately.</paragraph>
                <paragraph>The <reference internal="True" refuri="object#object-replicator"><inline classes="std std-ref">Object Replicator</inline></reference> is policy aware in that, depending on the policy,
                    it may have to do drastically different things, or maybe not.  For example, the
                    difference in handling a replication job for 2x versus 3x is trivial; however,
                    the difference in handling replication between 3x and erasure code is most
                    definitely not.  In fact, the term ‘replication’ really isn’t appropriate for
                    some policies like erasure code; however, the majority of the framework for
                    collecting and processing jobs is common.  Thus, those functions in the
                    replicator are leveraged for all policies and then there is policy specific code
                    required for each policy, added when the policy is defined if needed.</paragraph>
                <paragraph>The ssync functionality is policy aware for the same reason. Some of the
                    other modules may not obviously be affected, but the back-end directory
                    structure owned by <literal classes="xref py py-class">Diskfile</literal> requires the policy index
                    parameter.  Therefore ssync being policy aware really means passing the
                    policy index along.  See <reference internal="True" reftitle="swift.obj.ssync_sender" refuri="object#module-swift.obj.ssync_sender"><literal classes="xref py py-class">ssync_sender</literal></reference> and
                    <reference internal="True" reftitle="swift.obj.ssync_receiver" refuri="object#module-swift.obj.ssync_receiver"><literal classes="xref py py-class">ssync_receiver</literal></reference> for more information on ssync.</paragraph>
                <paragraph>For <literal classes="xref py py-class">Diskfile</literal> itself, being policy aware is all about managing the
                    back-end structure using the provided policy index.  In other words, callers who
                    get a <literal classes="xref py py-class">Diskfile</literal> instance provide a policy index and
                    <literal classes="xref py py-class">Diskfile</literal>’s job is to keep data separated via this index (however it
                    chooses) such that policies can share the same media/nodes if desired.  The
                    included implementation of <literal classes="xref py py-class">Diskfile</literal> lays out the directory structure
                    described earlier but that’s owned within <literal classes="xref py py-class">Diskfile</literal>; external modules
                    have no visibility into that detail.  A common function is provided to map
                    various directory names and/or strings based on their policy index. For example
                    <literal classes="xref py py-class">Diskfile</literal> defines <literal classes="xref py py-func">get_data_dir()</literal> which builds off of a generic
                    <reference internal="True" reftitle="swift.common.storage_policy.get_policy_string" refuri="misc#swift.common.storage_policy.get_policy_string"><literal classes="xref py py-func">get_policy_string()</literal></reference> to consistently build policy aware strings for
                    various usage.</paragraph>
            </section>
            <section ids="container-server" names="container\ server">
                <title>Container Server</title>
                <paragraph>The <reference internal="True" refuri="container#container-server"><inline classes="std std-ref">Container Server</inline></reference> plays a very important role in Storage Policies, it
                    is responsible for handling the assignment of a policy to a container and the
                    prevention of bad things like changing policies or picking the wrong policy to
                    use when nothing is specified (recall earlier discussion on Policy-0 versus
                    default).</paragraph>
                <paragraph>The <reference internal="True" refuri="container#container-updater"><inline classes="std std-ref">Container Updater</inline></reference> is policy aware, however its job is very simple, to
                    pass the policy index along to the <reference internal="True" refuri="account#account-server"><inline classes="std std-ref">Account Server</inline></reference> via a request header.</paragraph>
                <paragraph>The <reference internal="True" refuri="container#container-backend"><inline classes="std std-ref">Container Backend</inline></reference> is responsible for both altering existing DB
                    schema as well as assuring new DBs are created with a schema that supports
                    storage policies.  The “on-demand” migration of container schemas allows Swift
                    to upgrade without downtime (sqlite’s alter statements are fast regardless of
                    row count).  To support rolling upgrades (and downgrades) the incompatible
                    schema changes to the <literal>container_stat</literal> table are made to a
                    <literal>container_info</literal> table, and the <literal>container_stat</literal> table is replaced with a
                    view that includes an <literal>INSTEAD OF UPDATE</literal> trigger which makes it behave like
                    the old table.</paragraph>
                <paragraph>The policy index is stored here for use in reporting information
                    about the container as well as managing split-brain scenario induced
                    discrepancies between containers and their storage policies.  Furthermore,
                    during split-brain, containers must be prepared to track object updates from
                    multiple policies so the object table also includes a
                    <literal>storage_policy_index</literal> column.  Per-policy object counts and bytes are
                    updated in the <literal>policy_stat</literal> table using <literal>INSERT</literal> and <literal>DELETE</literal> triggers
                    similar to the pre-policy triggers that updated <literal>container_stat</literal> directly.</paragraph>
                <paragraph>The <reference internal="True" refuri="container#container-replicator"><inline classes="std std-ref">Container Replicator</inline></reference> daemon will pro-actively migrate legacy
                    schemas as part of its normal consistency checking process when it updates the
                    <literal>reconciler_sync_point</literal> entry in the <literal>container_info</literal> table.  This ensures
                    that read heavy containers which do not encounter any writes will still get
                    migrated to be fully compatible with the post-storage-policy queries without
                    having to fall back and retry queries with the legacy schema to service
                    container read requests.</paragraph>
                <paragraph>The <reference internal="True" refuri="container#container-sync-daemon"><inline classes="std std-ref">Container Sync</inline></reference> functionality only needs to be policy aware in
                    that it accesses the object rings.  Therefore, it needs to pull the policy index
                    out of the container information and use it to select the appropriate object
                    ring from the <literal classes="xref py py-data">POLICIES</literal> global.</paragraph>
            </section>
            <section ids="account-server" names="account\ server">
                <title>Account Server</title>
                <paragraph>The <reference internal="True" refuri="account#account-server"><inline classes="std std-ref">Account Server</inline></reference>’s role in Storage Policies is really limited to
                    reporting. When a HEAD request is made on an account (see example provided
                    earlier), the account server is provided with the storage policy index and
                    builds the <literal>object_count</literal> and <literal>byte_count</literal> information for the client on a
                    per policy basis.</paragraph>
                <paragraph>The account servers are able to report per-storage-policy object and byte
                    counts because of some policy specific DB schema changes.  A policy specific
                    table, <literal>policy_stat</literal>, maintains information on a per policy basis (one row
                    per policy) in the same manner in which the <literal>account_stat</literal> table does.  The
                    <literal>account_stat</literal> table still serves the same purpose and is not replaced by
                    <literal>policy_stat</literal>, it holds the total account stats whereas <literal>policy_stat</literal> just
                    has the break downs.  The backend is also responsible for migrating
                    pre-storage-policy accounts by altering the DB schema and populating the
                    <literal>policy_stat</literal> table for Policy-0 with current <literal>account_stat</literal> data at that
                    point in time.</paragraph>
                <paragraph>The per-storage-policy object and byte counts are not updated with each object
                    PUT and DELETE request, instead container updates to the account server are
                    performed asynchronously by the <literal>swift-container-updater</literal>.</paragraph>
                <target refid="upgrade-policy"></target>
            </section>
            <section ids="upgrading-and-confirming-functionality upgrade-policy" names="upgrading\ and\ confirming\ functionality upgrade-policy">
                <title>Upgrading and Confirming Functionality</title>
                <paragraph>Upgrading to a version of Swift that has Storage Policy support is not
                    difficult, in fact, the cluster administrator isn’t required to make any special
                    configuration changes to get going.  Swift will automatically begin using the
                    existing object ring as both the default ring and the Policy-0 ring.  Adding the
                    declaration of policy 0 is totally optional and in its absence, the name given
                    to the implicit policy 0 will be ‘Policy-0’.  Let’s say for testing purposes
                    that you wanted to take an existing cluster that already has lots of data on it
                    and upgrade to Swift with Storage Policies. From there you want to go ahead and
                    create a policy and test a few things out.  All you need to do is:</paragraph>
                <block_quote>
                    <enumerated_list enumtype="arabic" prefix="" suffix=".">
                        <list_item>
                            <paragraph>Upgrade all of your Swift nodes to a policy-aware version of Swift</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>Define your policies in <literal>/etc/swift/swift.conf</literal></paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>Create the corresponding object rings</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>Create containers and objects and confirm their placement is as expected</paragraph>
                        </list_item>
                    </enumerated_list>
                </block_quote>
                <paragraph>For a specific example that takes you through these steps, please see
                    <reference internal="True" refuri="policies_saio"><inline classes="doc">Adding Storage Policies to an Existing SAIO</inline></reference></paragraph>
                <note>
                    <paragraph>If you downgrade from a Storage Policy enabled version of Swift to an
                        older version that doesn’t support policies, you will not be able to
                        access any data stored in policies other than the policy with index 0 but
                        those objects WILL appear in container listings (possibly as duplicates if
                        there was a network partition and un-reconciled objects).  It is EXTREMELY
                        important that you perform any necessary integration testing on the
                        upgraded deployment before enabling an additional storage policy to ensure
                        a consistent API experience for your clients.  DO NOT downgrade to a
                        version of Swift that does not support storage policies once you expose
                        multiple storage policies.</paragraph>
                </note>
            </section>
        </section>
    </section>
</document>
