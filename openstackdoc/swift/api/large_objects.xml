<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.14 -->
<document source="/home/fbaumanis/openstack/soc8_test/openstack_repo/swift/doc/source/api/large_objects.rst">
    <section ids="large-objects" names="large\ objects">
        <title>Large objects</title>
        <paragraph>By default, the content of an object cannot be greater than 5 GB.
            However, you can use a number of smaller objects to construct a large
            object. The large object is comprised of two types of objects:</paragraph>
        <bullet_list bullet="-">
            <list_item>
                <paragraph><strong>Segment objects</strong> store the object content. You can divide your
                    content into segments, and upload each segment into its own segment
                    object. Segment objects do not have any special features. You create,
                    update, download, and delete segment objects just as you would normal
                    objects.</paragraph>
            </list_item>
            <list_item>
                <paragraph>A <strong>manifest object</strong> links the segment objects into one logical
                    large object. When you download a manifest object, Object Storage
                    concatenates and returns the contents of the segment objects in the
                    response body of the request. This behavior extends to the response
                    headers returned by <strong>GET</strong> and <strong>HEAD</strong> requests. The
                    <literal>Content-Length</literal> response header value is the total size of all
                    segment objects. Object Storage calculates the <literal>ETag</literal> response
                    header value by taking the <literal>ETag</literal> value of each segment,
                    concatenating them together, and returning the MD5 checksum of the
                    result. The manifest object types are:</paragraph>
                <definition_list>
                    <definition_list_item>
                        <term><strong>Static large objects</strong></term>
                        <definition>
                            <paragraph>The manifest object content is an ordered list of the names of
                                the segment objects in JSON format.</paragraph>
                        </definition>
                    </definition_list_item>
                    <definition_list_item>
                        <term><strong>Dynamic large objects</strong></term>
                        <definition>
                            <paragraph>The manifest object has a <literal>X-Object-Manifest</literal> metadata header.
                                The value of this header is <literal>{container}/{prefix}</literal>,
                                where <literal>{container}</literal> is the name of the container where the
                                segment objects are stored, and <literal>{prefix}</literal> is a string that all
                                segment objects have in common. The manifest object should have
                                no content. However, this is not enforced.</paragraph>
                        </definition>
                    </definition_list_item>
                </definition_list>
            </list_item>
        </bullet_list>
        <section ids="note" names="note">
            <title>Note</title>
            <paragraph>If you make a <strong>COPY</strong> request by using a manifest object as the source,
                the new object is a normal, and not a segment, object. If the total size
                of the source segment objects exceeds 5 GB, the <strong>COPY</strong> request fails.
                However, you can make a duplicate of the manifest object and this new
                object can be larger than 5 GB.</paragraph>
        </section>
        <section ids="static-large-objects" names="static\ large\ objects">
            <title>Static large objects</title>
            <paragraph>To create a static large object, divide your content into pieces and
                create (upload) a segment object to contain each piece.</paragraph>
            <paragraph>Create a manifest object. Include the <literal>multipart-manifest=put</literal>
                query string at the end of the manifest object name to indicate that
                this is a manifest object.</paragraph>
            <paragraph>The body of the <strong>PUT</strong> request on the manifest object comprises a json
                list, where each element is an object representing a segment. These objects
                may contain the following attributes:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><literal>path</literal> (required). The container and object name in the format:
                        <literal>{container-name}/{object-name}</literal></paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>etag</literal> (optional). If provided, this value must match the <literal>ETag</literal>
                        of the segment object. This was included in the response headers when
                        the segment was created. Generally, this will be the MD5 sum of the
                        segment.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>size_bytes</literal> (optional). The size of the segment object. If provided,
                        this value must match the <literal>Content-Length</literal> of that object.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>range</literal> (optional). The subset of the referenced object that should
                        be used for segment data. This behaves similar to the <literal>Range</literal> header.
                        If omitted, the entire object will be used.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>Providing the optional <literal>etag</literal> and <literal>size_bytes</literal> attributes for each
                segment ensures that the upload cannot corrupt your data.</paragraph>
            <paragraph><strong>Example Static large object manifest list</strong></paragraph>
            <paragraph>This example shows three segment objects. You can use several containers
                and the object names do not have to conform to a specific pattern, in
                contrast to dynamic large objects.</paragraph>
            <literal_block classes="code" xml:space="preserve">[
    {
        "path": "mycontainer/objseg1",
        "etag": "0228c7926b8b642dfb29554cd1f00963",
        "size_bytes": 1468006
    },
    {
        "path": "mycontainer/pseudodir/seg-obj2",
        "etag": "5bfc9ea51a00b790717eeb934fb77b9b",
        "size_bytes": 1572864
    },
    {
        "path": "other-container/seg-final",
        "etag": "b9c3da507d2557c1ddc51f27c54bae51",
        "size_bytes": 256
    }
]</literal_block>
            <line_block>
                <line></line>
            </line_block>
            <paragraph>The <literal>Content-Length</literal> request header must contain the length of the
                json contentâ€”not the length of the segment objects. However, after the
                <strong>PUT</strong> operation completes, the <literal>Content-Length</literal> metadata is set to
                the total length of all the object segments. When using the <literal>ETag</literal>
                request header in a <strong>PUT</strong> operation, it  must contain the MD5 checksum
                of the concatenated <literal>ETag</literal> values of the object segments. You can also
                set the <literal>Content-Type</literal> request header and custom object metadata.</paragraph>
            <paragraph>When the <strong>PUT</strong> operation sees the <literal>multipart-manifest=put</literal> query
                string, it reads the request body and verifies that each segment
                object exists and that the sizes and ETags match. If there is a
                mismatch, the <strong>PUT</strong>operation fails.</paragraph>
            <paragraph>If everything matches, the manifest object is created. The
                <literal>X-Static-Large-Object</literal> metadata is set to <literal>true</literal> indicating that
                this is a static object manifest.</paragraph>
            <paragraph>Normally when you perform a <strong>GET</strong> operation on the manifest object,
                the response body contains the concatenated content of the segment
                objects. To download the manifest list, use the
                <literal>multipart-manifest=get</literal> query string. The resulting list is not
                formatted the same as the manifest you originally used in the <strong>PUT</strong>
                operation.</paragraph>
            <paragraph>If you use the <strong>DELETE</strong> operation on a manifest object, the manifest
                object is deleted. The segment objects are not affected. However, if you
                add the <literal>multipart-manifest=delete</literal> query string, the segment
                objects are deleted and if all are successfully deleted, the manifest
                object is also deleted.</paragraph>
            <paragraph>To change the manifest, use a <strong>PUT</strong> operation with the
                <literal>multipart-manifest=put</literal> query string. This request creates a
                manifest object. You can also update the object metadata in the usual
                way.</paragraph>
        </section>
        <section ids="dynamic-large-objects" names="dynamic\ large\ objects">
            <title>Dynamic large objects</title>
            <paragraph>You must segment objects that are larger than 5 GB before you can upload
                them. You then upload the segment objects like you would any other
                object and create a dynamic large manifest object. The manifest object
                tells Object Storage how to find the segment objects that comprise the
                large object. The segments remain individually addressable, but
                retrieving the manifest object streams all the segments concatenated.
                There is no limit to the number of segments that can be a part of a
                single large object.</paragraph>
            <paragraph>To ensure the download works correctly, you must upload all the object
                segments to the same container and ensure that each object name is
                prefixed in such a way that it sorts in the order in which it should be
                concatenated. You also create and upload a manifest file. The manifest
                file is a zero-byte file with the extra <literal>X-Object-Manifest</literal>
                <literal>{container}/{prefix}</literal> header, where <literal>{container}</literal> is the container
                the object segments are in and <literal>{prefix}</literal> is the common prefix for all
                the segments. You must UTF-8-encode and then URL-encode the container
                and common prefix in the <literal>X-Object-Manifest</literal> header.</paragraph>
            <paragraph>It is best to upload all the segments first and then create or update
                the manifest. With this method, the full object is not available for
                downloading until the upload is complete. Also, you can upload a new set
                of segments to a second location and update the manifest to point to
                this new location. During the upload of the new segments, the original
                manifest is still available to download the first set of segments.</paragraph>
            <note>
                <paragraph>When updating a manifest object using a POST request, a
                    <literal>X-Object-Manifest</literal> header must be included for the
                    object to continue to behave as a manifest object.</paragraph>
            </note>
            <paragraph><strong>Example Upload segment of large object request: HTTP</strong></paragraph>
            <literal_block classes="code" xml:space="preserve">PUT /{api_version}/{account}/{container}/{object} HTTP/1.1
Host: storage.clouddrive.com
X-Auth-Token: eaaafd18-0fed-4b3a-81b4-663c99ec1cbb
ETag: 8a964ee2a5e88be344f36c22562a6486
Content-Length: 1
X-Object-Meta-PIN: 1234</literal_block>
            <paragraph>No response body is returned. A status code of 2<emphasis>``nn``</emphasis> (between 200
                and 299, inclusive) indicates a successful write; status 411 Length
                Required denotes a missing <literal>Content-Length</literal> or <literal>Content-Type</literal> header
                in the request. If the MD5 checksum of the data written to the storage
                system does NOT match the (optionally) supplied ETag value, a 422
                Unprocessable Entity response is returned.</paragraph>
            <paragraph>You can continue uploading segments like this example shows, prior to
                uploading the manifest.</paragraph>
            <paragraph><strong>Example Upload next segment of large object request: HTTP</strong></paragraph>
            <literal_block classes="code" xml:space="preserve">PUT /{api_version}/{account}/{container}/{object} HTTP/1.1
Host: storage.clouddrive.com
X-Auth-Token: eaaafd18-0fed-4b3a-81b4-663c99ec1cbb
ETag: 8a964ee2a5e88be344f36c22562a6486
Content-Length: 1
X-Object-Meta-PIN: 1234</literal_block>
            <paragraph>Next, upload the manifest you created that indicates the container the
                object segments reside within. Note that uploading additional segments
                after the manifest is created causes the concatenated object to be that
                much larger but you do not need to recreate the manifest file for
                subsequent additional segments.</paragraph>
            <paragraph><strong>Example Upload manifest request: HTTP</strong></paragraph>
            <literal_block classes="code" xml:space="preserve">PUT /{api_version}/{account}/{container}/{object} HTTP/1.1
Host: storage.clouddrive.com
X-Auth-Token: eaaafd18-0fed-4b3a-81b4-663c99ec1cbb
Content-Length: 0
X-Object-Meta-PIN: 1234
X-Object-Manifest: {container}/{prefix}</literal_block>
            <paragraph><strong>Example Upload manifest response: HTTP</strong></paragraph>
            <literal_block classes="code" xml:space="preserve">[...]</literal_block>
            <paragraph>The <literal>Content-Type</literal> in the response for a <strong>GET</strong> or <strong>HEAD</strong> on the
                manifest is the same as the <literal>Content-Type</literal> set during the <strong>PUT</strong>
                request that created the manifest. You can easily change the
                <literal>Content-Type</literal> by reissuing the <strong>PUT</strong> request.</paragraph>
        </section>
        <section ids="comparison-of-static-and-dynamic-large-objects" names="comparison\ of\ static\ and\ dynamic\ large\ objects">
            <title>Comparison of static and dynamic large objects</title>
            <paragraph>While static and dynamic objects have similar behavior, here are
                their differences:</paragraph>
            <section ids="end-to-end-integrity" names="end-to-end\ integrity">
                <title>End-to-end integrity</title>
                <paragraph>With static large objects, integrity can be assured.
                    The list of segments may include the MD5 checksum (<literal>ETag</literal>) of each segment.
                    You cannot upload the manifest object if the <literal>ETag</literal> in the list differs
                    from the uploaded segment object. If a segment is somehow lost, an attempt
                    to download the manifest object results in an error.</paragraph>
                <paragraph>With dynamic large objects, integrity is not guaranteed. The eventual
                    consistency model means that although you have uploaded a segment object, it
                    might not appear in the container listing until later. If you download the
                    manifest before it appears in the container, it does not form part of the
                    content returned in response to a <strong>GET</strong> request.</paragraph>
            </section>
            <section ids="upload-order" names="upload\ order">
                <title>Upload Order</title>
                <paragraph>With static large objects, you must upload the
                    segment objects before you upload the manifest object.</paragraph>
                <paragraph>With dynamic large objects, you can upload manifest and segment objects
                    in any order. In case a premature download of the manifest occurs, we
                    recommend users upload the manifest object after the segments. However,
                    the system does not enforce the order.</paragraph>
            </section>
            <section ids="removal-or-addition-of-segment-objects" names="removal\ or\ addition\ of\ segment\ objects">
                <title>Removal or addition of segment objects</title>
                <paragraph>With static large objects, you cannot add or
                    remove segment objects from the manifest. However, you can create a
                    completely new manifest object of the same name with a different manifest
                    list.</paragraph>
                <paragraph>With dynamic large objects, you can upload new segment objects or remove
                    existing segments. The names must simply match the <literal>{prefix}</literal> supplied
                    in <literal>X-Object-Manifest</literal>.</paragraph>
            </section>
            <section ids="segment-object-size-and-number" names="segment\ object\ size\ and\ number">
                <title>Segment object size and number</title>
                <paragraph>With static large objects, the segment objects must be at least 1 byte in size.
                    However, if the segment objects are less than 1MB (by default),
                    the SLO download is (by default) rate limited. At most,
                    1000 segments are supported (by default) and the manifest has a limit
                    (by default) of 2MB in size.</paragraph>
                <paragraph>With dynamic large objects, segment objects can be any size.</paragraph>
            </section>
            <section ids="segment-object-container-name" names="segment\ object\ container\ name">
                <title>Segment object container name</title>
                <paragraph>With static large objects, the manifest list includes the container name of each object.
                    Segment objects can be in different containers.</paragraph>
                <paragraph>With dynamic large objects, all segment objects must be in the same container.</paragraph>
            </section>
            <section ids="manifest-object-metadata" names="manifest\ object\ metadata">
                <title>Manifest object metadata</title>
                <paragraph>With static large objects, the manifest object has <literal>X-Static-Large-Object</literal>
                    set to <literal>true</literal>. You do not set this
                    metadata directly. Instead the system sets it when you <strong>PUT</strong> a static
                    manifest object.</paragraph>
                <paragraph>With dynamic large objects, the <literal>X-Object-Manifest</literal> value is the
                    <literal>{container}/{prefix}</literal>, which indicates
                    where the segment objects are located. You supply this request header in the
                    <strong>PUT</strong> operation.</paragraph>
            </section>
            <section ids="copying-the-manifest-object" names="copying\ the\ manifest\ object">
                <title>Copying the manifest object</title>
                <paragraph>The semantics are the same for both static and dynamic large objects.
                    When copying large objects, the <strong>COPY</strong> operation does not create
                    a manifest object but a normal object with content same as what you would
                    get on a <strong>GET</strong> request to the original manifest object.</paragraph>
                <paragraph>To copy the manifest object, you include the <literal>multipart-manifest=get</literal>
                    query string in the <strong>COPY</strong>  request. The new object contains the same
                    manifest as the original. The segment objects are not copied. Instead,
                    both the original and new manifest objects share the same set of segment
                    objects.</paragraph>
            </section>
        </section>
    </section>
</document>
