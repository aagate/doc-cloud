<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document source="/home/fbaumanis/openstack/soc8_test/openstack_repo/horizon/doc/source/contributor/topics/angularjs.rst">
    <target refid="topics-angularjs"></target>
    <section ids="angularjs-topic-guide topics-angularjs" names="angularjs\ topic\ guide topics-angularjs">
        <title>AngularJS Topic Guide</title>
        <note>
            <paragraph>This guide is a work in progress. It has been uploaded to encourage faster
                reviewing and code development in Angular, and to help the community
                standardize on a set of guidelines. There are notes inline on sections
                that are likely to change soon, and the docs will be updated promptly
                after any changes.</paragraph>
        </note>
        <section ids="getting-started" names="getting\ started">
            <title>Getting Started</title>
            <paragraph>The tooling for AngularJS testing and code linting relies on npm, the
                node package manager, and thus relies on Node.js. While it is not a
                prerequisite to developing with Horizon, it is advisable to install Node.js,
                either through <reference name="downloading" refuri="https://nodejs.org/download/">downloading</reference><target ids="downloading" names="downloading" refuri="https://nodejs.org/download/"></target> or
                <reference name="via a package manager" refuri="https://github.com/joyent/node/wiki/Installing-Node.js-via-package-manager">via a package manager</reference><target ids="via-a-package-manager" names="via\ a\ package\ manager" refuri="https://github.com/joyent/node/wiki/Installing-Node.js-via-package-manager"></target>.</paragraph>
            <paragraph>Once you have npm available on your system, run <literal>npm install</literal> from the
                horizon root directory.</paragraph>
            <target refid="js-code-style"></target>
        </section>
        <section ids="code-style js-code-style" names="code\ style js_code_style">
            <title>Code Style</title>
            <paragraph>We currently use the <reference name="Angular Style Guide" refuri="https://github.com/johnpapa/angular-styleguide">Angular Style Guide</reference> by John Papa as reference material.
                When reviewing AngularJS code, it is helpful to link directly to the style
                guide to reinforce a point, e.g.
                <reference refuri="https://github.com/johnpapa/angular-styleguide#style-y024">https://github.com/johnpapa/angular-styleguide#style-y024</reference></paragraph>
            <target ids="angular-style-guide" names="angular\ style\ guide" refuri="https://github.com/johnpapa/angular-styleguide"></target>
            <section ids="eslint" names="eslint">
                <title>ESLint</title>
                <paragraph>ESLint is a tool for identifying and reporting on patterns in your JS code, and
                    is part of the automated tests run by Jenkins. You can run ESLint from the
                    horizon root directory with <literal>tox -e npm -- lint</literal>, or alternatively on a
                    specific directory or file with <literal>eslint file.js</literal>.</paragraph>
                <paragraph>Horizon includes a <title_reference>.eslintrc</title_reference> in its root directory, that is used by the
                    local tests. An explanation of the options, and details of others you may want
                    to use, can be found in the
                    <reference name="ESLint user guide" refuri="http://eslint.org/docs/user-guide/configuring">ESLint user guide</reference><target ids="eslint-user-guide" names="eslint\ user\ guide" refuri="http://eslint.org/docs/user-guide/configuring"></target>.</paragraph>
            </section>
        </section>
        <section ids="application-structure" names="application\ structure">
            <title>Application Structure</title>
            <paragraph>OpenStack Dashboard is an example of a Horizon-based Angular application. Other
                applications built on the Horizon framework can follow a similar structure. It
                is composed of two key Angular modules:</paragraph>
            <definition_list>
                <definition_list_item>
                    <term><strong>app.module.js</strong> - The root of the application. Defines the modules required by</term>
                    <definition>
                        <paragraph>the application, and includes modules from its pluggable dashboards.</paragraph>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term><strong>framework.module.js</strong> - Reusable Horizon components. It is one of the</term>
                    <definition>
                        <paragraph>application dependencies.</paragraph>
                    </definition>
                </definition_list_item>
            </definition_list>
            <target refid="js-file-structure"></target>
        </section>
        <section ids="file-structure js-file-structure" names="file\ structure js_file_structure">
            <title>File Structure</title>
            <paragraph>Horizon has three kinds of angular code:</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>Specific to one dashboard in the OpenStack Dashboard application</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Specific to the OpenStack Dashboard application, but reusable by multiple
                        dashboards</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Reusable by any application based on the Horizon framework</paragraph>
                </list_item>
            </enumerated_list>
            <paragraph>When adding code to horizon, consider whether it is dashboard-specific or
                should be broken out as a reusable utility or widget.</paragraph>
            <section ids="code-specific-to-one-dashboard" names="code\ specific\ to\ one\ dashboard">
                <title>Code specific to one dashboard</title>
                <paragraph>Code that isn’t shared beyond a single dashboard is placed in
                    <literal>openstack_dashboard/dashboards/mydashboard/static</literal>. Entire dashboards may be
                    enabled or disabled using Horizon’s plugin mechanism. Therefore no dashboards
                    other than <literal>mydashboard</literal> can safely use this code.</paragraph>
                <paragraph>The <literal>openstack_dashboard/dashboards/static</literal> directory structure determines
                    how the code is deployed and matches the module structure.
                    For example:</paragraph>
                <literal_block xml:space="preserve">openstack_dashboard/dashboards/identity/static/dashboard/identity/
├── identity.module.js
├── identity.module.spec.js
└── identity.scss</literal_block>
                <paragraph>Because the code is in <literal>openstack_dashboard/dashboards/identity</literal> we know it
                    is specific to just the <literal>identity</literal> dashboard and not used by any others.</paragraph>
            </section>
            <section ids="code-shared-by-multiple-dashboards" names="code\ shared\ by\ multiple\ dashboards">
                <title>Code shared by multiple dashboards</title>
                <paragraph>Views or utilities needed by multiple dashboards are placed in
                    <literal>openstack_dashboard/static/app</literal>. For example:</paragraph>
                <literal_block xml:space="preserve">openstack_dashboard/static/app/core/cloud-services/
├── cloud-services.module.js
├── cloud-services.spec.js
├── hz-if-settings.directive.js
└── hz-if-settings.directive.spec.js</literal_block>
                <paragraph>The <literal>cloud-services</literal> module is used by panels in multiple dashboards. It
                    cannot be placed within <literal>openstack_dashboard/dashboards/mydashboard</literal> because
                    disabling that one dashboard would break others. Therefore, it is included as
                    part of the application <literal>core</literal> module. Code in <literal>app/</literal> is guaranteed to
                    always be present, even if all other dashboards are disabled.</paragraph>
            </section>
            <section ids="reusable-components" names="reusable\ components">
                <title>Reusable components</title>
                <paragraph>Finally, components that are easily reused by any application are placed in
                    <literal>horizon/static/framework/</literal>. These do not contain URLs or business logic
                    that is specific to any application (even the OpenStack Dashboard application).</paragraph>
                <paragraph>The modal directive <literal>horizon/static/framework/widgets/modal/</literal> is a good
                    example of a reusable component.</paragraph>
            </section>
            <section ids="one-folder-per-component" names="one\ folder\ per\ component">
                <title>One folder per component</title>
                <paragraph>Each component should have its own folder, with the code broken up into one JS
                    component per file. (See <reference name="Single Responsibility" refuri="https://github.com/johnpapa/angular-styleguide#single-responsibility">Single Responsibility</reference><target ids="single-responsibility" names="single\ responsibility" refuri="https://github.com/johnpapa/angular-styleguide#single-responsibility"></target>
                    in the style guide).
                    Each folder may include styling (<literal>*.scss</literal>), as well as templates (<literal>*.html</literal>)
                    and tests (<literal>*.spec.js</literal>).
                    You may also include examples, by appending <literal>.example</literal>.</paragraph>
                <paragraph>For larger components, such as workflows with multiple steps, consider breaking
                    the code down further. For example, the Launch Instance workflow, has one
                    directory per step. See
                    <literal>openstack_dashboard/dashboards/project/static/dashboard/project/workflow/launch-instance/</literal></paragraph>
            </section>
            <section ids="scss-files" names="scss\ files">
                <title>SCSS files</title>
                <paragraph>The top-level SCSS file in <literal>openstack_dashboard/static/app/_app.scss</literal>. It
                    includes any styling that is part of the application <literal>core</literal> and may be
                    reused by multiple dashboards. SCSS files that are specific to a particular
                    dashboard are linked to the application by adding them in that dashboard’s
                    enabled file. For example, <title_reference>_1920_project_containers_panel.py</title_reference> is the enabled
                    file for the <literal>Project</literal> dashboard’s <literal>Container</literal> panel and includes:</paragraph>
                <literal_block xml:space="preserve">ADD_SCSS_FILES = [
    'dashboard/project/containers/_containers.scss',
]</literal_block>
                <paragraph>Styling files are hierarchical, and include any direct child SCSS files. For
                    example, <literal>project.scss</literal> would includes the <literal>workflow</literal> SCSS file, which in
                    turn includes any launch instance styling:</paragraph>
                <literal_block xml:space="preserve">@import "workflow/workflow";</literal_block>
                <paragraph>This allows the application to easily include all needed styling, simply by
                    including a dashboard’s top-level SCSS file.</paragraph>
            </section>
        </section>
        <section ids="module-structure" names="module\ structure">
            <title>Module Structure</title>
            <paragraph>Horizon Angular modules use names that map to the source code directory
                structure. This provides namespace isolation for modules and services, which
                makes dependency injection clearer. It also reduces code conflicts where two
                different modules define a module, service or constant of the same name. For
                example:</paragraph>
            <literal_block xml:space="preserve">openstack_dashboard/dashboards/identity/static/dashboard/identity/
└── identity.module.js</literal_block>
            <paragraph>The preferred Angular module name in this example is
                <literal>horizon.dashboard.identity</literal>. The <literal>horizon</literal> part of the module name maps to
                the <literal>static</literal> directory and indicates this is a <literal>horizon</literal> based application.
                <literal>dashboard.identity</literal> maps to folders that are created within <literal>static</literal>. This
                allows a direct mapping between the angular module name of
                <literal>horizon.dashboard.identity</literal> and the source code directory of
                <literal>static\dashboard\identity</literal>.</paragraph>
            <paragraph>Services and constants within these modules should all start with their module
                name to avoid dependency injection collisions. For example:</paragraph>
            <literal_block xml:space="preserve">$provide.constant('horizon.dashboard.identity.basePath', path);</literal_block>
            <paragraph>Directives do not require the module name but are encouraged to begin with the
                <literal>hz</literal> prefix. For example:</paragraph>
            <literal_block xml:space="preserve">.directive('hzMagicSearchBar', hzMagicSearchBar);</literal_block>
            <paragraph>Finally, each module lists its child modules as a dependency. This allows the
                root module to be included by an application, which will automatically define
                all child modules. For example:</paragraph>
            <literal_block xml:space="preserve">.module('horizon.framework', [
  'horizon.framework.conf',
  'horizon.framework.util',
  'horizon.framework.widgets'
])</literal_block>
            <paragraph><literal>horizon.framework</literal> declares a dependency on <literal>horizon.framework.widgets</literal>,
                which declares dependencies on each individual widget. This allows the
                application to access any widget, simply by depending on the top-level
                <literal>horizon.framework</literal> module.</paragraph>
        </section>
        <section ids="testing" names="testing">
            <title>Testing</title>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>Open &lt;dev_server_ip:port&gt;/jasmine in a browser. The development server can
                        be run with <literal>tox -e runserver</literal> from the horizon root directory; by
                        default, this will run the development server at <literal>http://localhost:8000</literal>.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>tox -e npm</literal> from the horizon root directory.</paragraph>
                </list_item>
            </enumerated_list>
            <paragraph>The code linting job can be run with <literal>tox -e npm -- lint</literal>. If there are many
                warnings, you can also use <literal>tox -e npm -- lintq</literal> to see only errors and
                ignore warnings.</paragraph>
            <paragraph>For more detailed information, see <reference internal="True" refuri="javascript_testing#topics-javascript-testing"><inline classes="std std-ref">JavaScript Testing</inline></reference>.</paragraph>
        </section>
        <section ids="translation-internationalization-and-localization" names="translation\ (internationalization\ and\ localization)">
            <title>Translation (Internationalization and Localization)</title>
            <paragraph>See <reference internal="True" refuri="translation#making-strings-translatable"><inline classes="std std-ref">Making strings translatable</inline></reference> for information on the translation
                architecture and how to ensure your code is translatable.</paragraph>
        </section>
        <section ids="creating-your-own-panel" names="creating\ your\ own\ panel">
            <title>Creating your own panel</title>
            <note>
                <paragraph>This section will be extended as standard practices are adopted upstream.
                    Currently, it may be useful to look at the Project Images Panel as a
                    complete reference. Since Newton, it is Angular by default (set to True in the
                    ANGULAR_FEATURES dict in <literal>settings.py</literal>).
                    You may track all the changes made to the Image Panel
                    <reference name="here" refuri="https://github.com/openstack/horizon/commits/master/openstack_dashboard/static/app/core/images">here</reference></paragraph>
            </note>
            <note>
                <paragraph>Currently, Angular module names must still be manually declared with
                    <literal>ADD_ANGULAR_MODULES</literal>, even when using automatic file discovery.</paragraph>
            </note>
            <paragraph>This section serves as a basic introduction to writing your own panel for
                horizon, using AngularJS. A panel may be included with the plugin system, or it
                may be part of the upstream horizon project.</paragraph>
            <section ids="upstream" names="upstream">
                <title>Upstream</title>
                <paragraph>JavaScript files can be discovered automatically, handled manually, or a mix of
                    the two. Where possible, use the automated mechanism.
                    To use the automatic functionality, add:</paragraph>
                <literal_block xml:space="preserve">AUTO_DISCOVER_STATIC_FILES = True</literal_block>
                <paragraph>to your enabled file (<literal>enabled/&lt;plugin_name&gt;.py</literal>). To make this possible,
                    you need to follow some structural conventions:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>Static files should be put in a <literal>static/</literal> folder, which should be found
                            directly under the folder for the dashboard/panel/panel groups Python
                            package.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>JS code that defines an Angular module should be in a file with extension of
                            <literal>.module.js</literal>.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>JS code for testing should be named with extension of <literal>.mock.js</literal> and of
                            <literal>.spec.js</literal>.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Angular templates should have extension of <literal>.html</literal>.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>You can read more about the functionality in the
                    <reference internal="True" refuri="../../configuration/pluggable_panels#auto-discover-static-files"><inline classes="std std-ref">AUTO_DISCOVER_STATIC_FILES</inline></reference> section of the settings documentation.</paragraph>
                <paragraph>To manually add files, add the following arrays and file paths to the enabled
                    file:</paragraph>
                <literal_block xml:space="preserve">ADD_JS_FILES = [
  ...
  'path-to/my-angular-code.js',
  ...
]

ADD_JS_SPEC_FILES = [
  ...
  'path-to/my-angular-code.spec.js',
  ...
]

ADD_ANGULAR_MODULES = [
  ...
  'my.angular.code',
  ...
]</literal_block>
            </section>
            <section ids="plugins" names="plugins">
                <title>Plugins</title>
                <paragraph>Add a new panel/ panel group/ dashboard (See <reference internal="True" refuri="../tutorials/dashboard#tutorials-dashboard"><inline classes="std std-ref">Tutorial: Building a Dashboard using Horizon</inline></reference>).
                    JavaScript file inclusion is the same as the Upstream process.</paragraph>
                <paragraph>To include external stylesheets, you must ensure that <literal>ADD_SCSS_FILES</literal> is
                    defined in your enabled file, and add the relevant filepath, as below:</paragraph>
                <literal_block xml:space="preserve">ADD_SCSS_FILES = [
  ...
  'path-to/my-styles.scss',
  ...
]</literal_block>
                <note>
                    <paragraph>We highly recommend using a single SCSS file for your plugin. SCSS supports
                        nesting with @import, so if you have multiple files (i.e. per panel styling)
                        it is best to import them all into one, and include that single file. You can
                        read more in the <reference name="SASS documentation" refuri="http://sass-lang.com/documentation/file.SASS_REFERENCE.html#import">SASS documentation</reference>.</paragraph>
                </note>
                <target ids="sass-documentation" names="sass\ documentation" refuri="http://sass-lang.com/documentation/file.SASS_REFERENCE.html#import"></target>
            </section>
        </section>
        <section ids="schema-forms" names="schema\ forms">
            <title>Schema Forms</title>
            <paragraph><reference name="JSON schemas" refuri="http://json-schema.org/">JSON schemas</reference> are used to define model layout and then <reference name="angular-schema-form" refuri="https://github.com/json-schema-form/angular-schema-form/blob/master/docs/index.md">angular-schema-form</reference>
                is used to create forms from that schema. Horizon adds some functionality on
                top of that to make things even easier through <literal>ModalFormService</literal> which will
                open a modal with the form inside.</paragraph>
            <paragraph>A very simple example:</paragraph>
            <literal_block xml:space="preserve">var schema = {
  type: "object",
  properties: {
    name: { type: "string", minLength: 2, title: "Name", description: "Name or alias" },
    title: {
      type: "string",
      enum: ['dr','jr','sir','mrs','mr','NaN','dj']
    }
  }
};
var model = {name: '', title: ''};
var config = {
  title: gettext('Create Container'),
  schema: schema,
  form: ['*'],
  model: model
};
ModalFormService.open(config).then(submit);   // returns a promise

function submit() {
  // do something with model.name and model.title
}</literal_block>
            <target ids="json-schemas" names="json\ schemas" refuri="http://json-schema.org/"></target>
            <target ids="angular-schema-form" names="angular-schema-form" refuri="https://github.com/json-schema-form/angular-schema-form/blob/master/docs/index.md"></target>
        </section>
    </section>
</document>
