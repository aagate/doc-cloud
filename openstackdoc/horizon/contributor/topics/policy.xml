<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document source="/home/fbaumanis/openstack/soc8_test/openstack_repo/horizon/doc/source/contributor/topics/policy.rst">
    <target refid="topics-policy"></target>
    <section ids="horizon-policy-enforcement-rbac-role-based-access-control topics-policy" names="horizon\ policy\ enforcement\ (rbac:\ role\ based\ access\ control) topics-policy">
        <title>Horizon Policy Enforcement (RBAC: Role Based Access Control)</title>
        <section ids="introduction" names="introduction">
            <title>Introduction</title>
            <paragraph>Horizon’s policy enforcement builds on the oslo_policy engine.
                The basis of which is <literal>openstack_auth/policy.py</literal>.
                Services in OpenStack use the oslo policy engine to define policy rules
                to limit access to APIs based primarily on role grants and resource
                ownership.</paragraph>
            <paragraph>The Keystone v3 API provides an interface for creating/reading/updating
                policy files in the keystone database. However, at this time services
                do not load the policy files into Keystone. Thus, the implementation in
                Horizon is based on copies of policy.json files found in the service’s
                source code. The long-term goal is to read/utilize/update these policy
                files in Horizon.</paragraph>
            <paragraph>The service rules files are loaded into the policy engine to determine
                access rights to actions and service APIs.</paragraph>
        </section>
        <section ids="horizon-settings" names="horizon\ settings">
            <title>Horizon Settings</title>
            <paragraph>There are a few settings that must be in place for the Horizon policy
                engine to work.</paragraph>
            <section ids="policy-files-path" names="policy_files_path">
                <title><literal>POLICY_FILES_PATH</literal></title>
                <paragraph>Default:  <literal>os.path.join(ROOT_PATH, "conf")</literal></paragraph>
                <paragraph>Specifies where service based policy files are located.  These are used to
                    define the policy rules actions are verified against.  This value must contain
                    the files listed in <literal>POLICY_FILES</literal> or all policy checks will pass.</paragraph>
                <note>
                    <paragraph>The path to deployment specific policy files can be specified in
                        <literal>local_settings.py</literal> to override the default location.</paragraph>
                </note>
            </section>
            <section ids="policy-files" names="policy_files">
                <title><literal>POLICY_FILES</literal></title>
                <paragraph>Default: <literal>{'identity': 'keystone_policy.json', 'compute': 'nova_policy.json'}</literal></paragraph>
                <paragraph>This should essentially be the mapping of the contents of <literal>POLICY_FILES_PATH</literal>
                    to service types.  When policy.json files are added to the directory
                    <literal>POLICY_FILES_PATH</literal>, they should be included here too. Without this mapping,
                    there is no way to map service types with policy rules, thus two policy.json
                    files containing a “default” rule would be ambiguous.</paragraph>
                <note>
                    <paragraph>Deployment specific policy files can be specified in <literal>local_settings.py</literal>
                        to override the default policy files. It is imperative that these policy
                        files match those deployed in the target OpenStack installation. Otherwise,
                        the displayed actions and the allowed action will not match.</paragraph>
                </note>
            </section>
            <section ids="policy-check-function" names="policy_check_function">
                <title><literal>POLICY_CHECK_FUNCTION</literal></title>
                <paragraph>Default: <literal>policy.check</literal></paragraph>
                <paragraph>This value should not be changed, although removing it would be a means to
                    bypass all policy checks. Set it to <literal>None</literal> in <literal>local_settings.py</literal> to
                    do this.</paragraph>
            </section>
        </section>
        <section ids="how-user-s-roles-are-determined" names="how\ user's\ roles\ are\ determined">
            <title>How user’s roles are determined</title>
            <paragraph>Each policy check uses information about the user stored on the request to
                determine the user’s roles. This information was extracted from the scoped
                token received from Keystone when authenticating.</paragraph>
            <paragraph>Entity ownership is also a valid role. To verify access to specific entities
                like a project, the target must be specified. See the section
                <reference internal="True" refid="rule-targets"><inline classes="std std-ref">rule targets</inline></reference> later in this document.</paragraph>
        </section>
        <section ids="how-to-utilize-rbac" names="how\ to\ utilize\ rbac">
            <title>How to Utilize RBAC</title>
            <paragraph>The primary way to add role based access control checks to panels is in the
                definition of table actions. When implementing a derived action class,
                setting the <reference internal="True" reftitle="horizon.tables.Action.policy_rules" refuri="../ref/tables#horizon.tables.Action.policy_rules"><literal classes="xref py py-attr">policy_rules</literal></reference> attribute to valid
                policy rules will force a policy check before the
                <literal classes="xref py py-meth">horizon.tables.Action.allowed()</literal> method is called on the action. These
                rules are defined in the policy files pointed to by <literal>POLICY_PATH</literal> and
                <literal>POLICY_FILES</literal>. The rules are role based, where entity owner is also a
                role. The format for the <literal>policy_rules</literal> is a list of two item tuples. The
                first component of the tuple is the scope of the policy rule, this is the
                service type. This informs the policy engine which policy file to reference.
                The second component is the rule to enforce from the policy file specified by
                the scope. An example tuple is:</paragraph>
            <literal_block xml:space="preserve">("identity", "identity:get_user")</literal_block>
            <paragraph>x tuples can be added to enforce x rules.</paragraph>
            <note>
                <paragraph>If a rule specified is not found in the policy file, the policy check
                    will return False and the action will not be allowed.</paragraph>
            </note>
            <paragraph>The secondary way to add a role based check is to directly use the
                <literal classes="xref py py-meth">check()</literal> method.  The method takes a list
                of actions, same format as the <reference internal="True" reftitle="horizon.tables.Action.policy_rules" refuri="../ref/tables#horizon.tables.Action.policy_rules"><literal classes="xref py py-attr">policy_rules</literal></reference>
                attribute detailed above; the current request object; and a dictionary of
                action targets. This is the method that <reference internal="True" reftitle="horizon.tables.Action" refuri="../ref/tables#horizon.tables.Action"><literal classes="xref py py-class">horizon.tables.Action</literal></reference> class
                utilizes.  Examples look like:</paragraph>
            <literal_block xml:space="preserve">from openstack_dashboard import policy

allowed = policy.check((("identity", "identity:get_user"),
                       ("identity", "identity:get_project"),), request)

can_see = policy.check((("identity", "identity:get_user"),), request,
                       target={"domain_id": domainId})</literal_block>
            <note>
                <paragraph>Any time multiple rules are specified in a single <title_reference>policy.check</title_reference> method
                    call, the result is the logical <title_reference>and</title_reference> of each rule check. So, if any
                    rule fails verification, the result is <title_reference>False</title_reference>.</paragraph>
            </note>
            <paragraph>The third way to add a role based check is in javascript files. Use the method
                ‘ifAllowed()’ in file ‘openstack_dashboard.static.app.core.policy.service.js’.
                The method takes a list of actions, similar format with the
                <reference internal="True" reftitle="horizon.tables.Action.policy_rules" refuri="../ref/tables#horizon.tables.Action.policy_rules"><literal classes="xref py py-attr">policy_rules</literal></reference> attribute detailed above.
                An Example looks like:</paragraph>
            <literal_block xml:space="preserve">angular
.module('horizon.dashboard.identity.users')
.controller('identityUsersTableController', identityUsersTableController);

identityUsersTableController.$inject = [
  'horizon.app.core.openstack-service-api.policy',
];

function identityUsersTableController(toast, gettext, policy, keystone) {
  var rules = [['identity', 'identity:list_users']];
  policy.ifAllowed({ rules: rules }).then(policySuccess, policyFailed);
}</literal_block>
            <paragraph>The fourth way to add a role based check is in html files. Use angular
                directive ‘hz-if-policies’ in file
                ‘openstack_dashboard/static/app/core/cloud-services/hz-if-policies.directive.js’.
                Assume you have the following policy defined in your angular controller:</paragraph>
            <literal_block xml:space="preserve">ctrl.policy = { rules: [["identity", "identity:update_user"]] }</literal_block>
            <paragraph>Then in your HTML, use it like so:</paragraph>
            <literal_block xml:space="preserve">&lt;div hz-if-policies='ctrl.policy'&gt;
  &lt;span&gt;I am visible if the policy is allowed!&lt;/span&gt;
&lt;/div&gt;</literal_block>
            <target refid="rule-targets"></target>
        </section>
        <section ids="rule-targets id1" names="rule\ targets rule_targets">
            <title>Rule Targets</title>
            <paragraph>Some rules allow access if the user owns the entity. Policy check targets
                specify particular entities to check for user ownership. The target parameter
                to the <literal classes="xref py py-meth">check()</literal> method is a simple dictionary.
                For instance, the target for checking access a project looks like:</paragraph>
            <literal_block xml:space="preserve">{"project_id": "0905760626534a74979afd3f4a9d67f1"}</literal_block>
            <paragraph>If the value matches the <literal>project_id</literal> to which the user’s token is scoped,
                then access is allowed.</paragraph>
            <paragraph>When deriving the <reference internal="True" reftitle="horizon.tables.Action" refuri="../ref/tables#horizon.tables.Action"><literal classes="xref py py-class">horizon.tables.Action</literal></reference> class for use in a table, if
                a policy check is desired for a particular target, the implementer should
                override the <literal classes="xref py py-meth">horizon.tables.Action.get_policy_target()</literal> method. This
                allows a programmatic way to specify the target based on the current datum. The
                value returned should be the target dictionary.</paragraph>
        </section>
    </section>
</document>
