<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document source="/home/fbaumanis/openstack/soc8_test/openstack_repo/horizon/doc/source/contributor/topics/tables.rst">
    <target refid="topics-datatables"></target>
    <section ids="datatables-topic-guide topics-datatables" names="datatables\ topic\ guide topics-datatables">
        <title>DataTables Topic Guide</title>
        <paragraph>Horizon provides the <reference internal="True" reftitle="horizon.tables" refuri="../ref/tables#module-horizon.tables"><literal classes="xref py py-mod">horizon.tables</literal></reference> module to provide
            a convenient, reusable API for building data-driven displays and interfaces.
            The core components of this API fall into three categories: <literal>DataTables</literal>,
            <literal>Actions</literal>, and <literal>Class-based Views</literal>.</paragraph>
        <seealso>
            <paragraph>For a detailed API information check out the <reference internal="True" refuri="../ref/tables#ref-datatables"><inline classes="std std-ref">Horizon DataTables</inline></reference>.</paragraph>
        </seealso>
        <section ids="tables" names="tables">
            <title>Tables</title>
            <paragraph>The majority of interface in a dashboard-style interface ends up being
                tabular displays of the various resources the dashboard interacts with.
                The <reference internal="True" reftitle="horizon.tables.DataTable" refuri="../ref/tables#horizon.tables.DataTable"><literal classes="xref py py-class">DataTable</literal></reference> class exists so you don’t have to
                reinvent the wheel each time.</paragraph>
            <section ids="creating-your-own-tables" names="creating\ your\ own\ tables">
                <title>Creating your own tables</title>
                <paragraph>Creating a table is fairly simple:</paragraph>
                <enumerated_list enumtype="arabic" prefix="" suffix=".">
                    <list_item>
                        <paragraph>Create a subclass of <reference internal="True" reftitle="horizon.tables.DataTable" refuri="../ref/tables#horizon.tables.DataTable"><literal classes="xref py py-class">DataTable</literal></reference>.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Define columns on it using <reference internal="True" reftitle="horizon.tables.Column" refuri="../ref/tables#horizon.tables.Column"><literal classes="xref py py-class">Column</literal></reference>.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Create an inner <literal>Meta</literal> class to contain the special options for
                            this table.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Define any actions for the table, and add them to
                            <reference internal="True" reftitle="horizon.tables.DataTableOptions.table_actions" refuri="../ref/tables#horizon.tables.DataTableOptions.table_actions"><literal classes="xref py py-attr">table_actions</literal></reference> or
                            <reference internal="True" reftitle="horizon.tables.DataTableOptions.row_actions" refuri="../ref/tables#horizon.tables.DataTableOptions.row_actions"><literal classes="xref py py-attr">row_actions</literal></reference>.</paragraph>
                    </list_item>
                </enumerated_list>
                <paragraph>Examples of this can be found in any of the <literal>tables.py</literal> modules included
                    in the reference modules under <literal>horizon.dashboards</literal>.</paragraph>
            </section>
            <section ids="connecting-a-table-to-a-view" names="connecting\ a\ table\ to\ a\ view">
                <title>Connecting a table to a view</title>
                <paragraph>Once you’ve got your table set up the way you like it, the next step is to
                    wire it up to a view. To make this as easy as possible Horizon provides the
                    <reference internal="True" reftitle="horizon.tables.DataTableView" refuri="../ref/tables#horizon.tables.DataTableView"><literal classes="xref py py-class">DataTableView</literal></reference> class-based view which can be subclassed
                    to display your table with just a couple lines of code. At its simplest, it
                    looks like this:</paragraph>
                <literal_block xml:space="preserve">from horizon import tables
from .tables import MyTable


class MyTableView(tables.DataTableView):
    table_class = MyTable
    template_name = "my_app/my_table_view.html"

    def get_data(self):
        return my_api.objects.list()</literal_block>
                <paragraph>In the template you would just need to include the following to render the
                    table:</paragraph>
                <literal_block xml:space="preserve">{{ table.render }}</literal_block>
                <paragraph>That’s it! Easy, right?</paragraph>
            </section>
        </section>
        <section ids="actions" names="actions">
            <title>Actions</title>
            <paragraph>Actions comprise any manipulations that might happen on the data in the table
                or the table itself. For example, this may be the standard object CRUD, linking
                to related views based on the object’s id, filtering the data in the table,
                or fetching updated data when appropriate.</paragraph>
            <section ids="when-actions-get-run" names="when\ actions\ get\ run">
                <title>When actions get run</title>
                <paragraph>There are two points in the request-response cycle in which actions can
                    take place; prior to data being loaded into the table, and after the data
                    is loaded. When you’re using one of the pre-built class-based views for
                    working with your tables the pseudo-workflow looks like this:</paragraph>
                <enumerated_list enumtype="arabic" prefix="" suffix=".">
                    <list_item>
                        <paragraph>The request enters view.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>The table class is instantiated without data.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Any “preemptive” actions are checked to see if they should run.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Data is fetched and loaded into the table.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>All other actions are checked to see if they should run.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>If none of the actions have caused an early exit from the view,
                            the standard response from the view is returned (usually the
                            rendered table).</paragraph>
                    </list_item>
                </enumerated_list>
                <paragraph>The benefit of the multi-step table instantiation is that you can use
                    preemptive actions which don’t need access to the entire collection of data
                    to save yourself on processing overhead, API calls, etc.</paragraph>
            </section>
            <section ids="basic-actions" names="basic\ actions">
                <title>Basic actions</title>
                <paragraph>At their simplest, there are three types of actions: actions which act on the
                    data in the table, actions which link to related resources, and actions that
                    alter which data is displayed. These correspond to
                    <reference internal="True" reftitle="horizon.tables.Action" refuri="../ref/tables#horizon.tables.Action"><literal classes="xref py py-class">Action</literal></reference>, <reference internal="True" reftitle="horizon.tables.LinkAction" refuri="../ref/tables#horizon.tables.LinkAction"><literal classes="xref py py-class">LinkAction</literal></reference>, and
                    <reference internal="True" reftitle="horizon.tables.FilterAction" refuri="../ref/tables#horizon.tables.FilterAction"><literal classes="xref py py-class">FilterAction</literal></reference>.</paragraph>
                <paragraph>Writing your own actions generally starts with subclassing one of those
                    action classes and customizing the designated attributes and methods.</paragraph>
            </section>
            <section ids="shortcut-actions" names="shortcut\ actions">
                <title>Shortcut actions</title>
                <paragraph>There are several common tasks for which Horizon provides pre-built shortcut
                    classes. These include <reference internal="True" reftitle="horizon.tables.BatchAction" refuri="../ref/tables#horizon.tables.BatchAction"><literal classes="xref py py-class">BatchAction</literal></reference>, and
                    <reference internal="True" reftitle="horizon.tables.DeleteAction" refuri="../ref/tables#horizon.tables.DeleteAction"><literal classes="xref py py-class">DeleteAction</literal></reference>. Each of these abstracts away nearly
                    all of the boilerplate associated with writing these types of actions and
                    provides consistent error handling, logging, and user-facing interaction.</paragraph>
                <paragraph>It is worth noting that <literal>BatchAction</literal> and <literal>DeleteAction</literal> are extensions
                    of the standard <literal>Action</literal> class. Some <literal>BatchAction</literal> or <literal>DeleteAction</literal>
                    classes may cause some unrecoverable results, like deleted images or
                    unrecoverable instances. It may be helpful to specify specific help_text to
                    explain the concern to the user, such as “Deleted images are not recoverable”.</paragraph>
            </section>
            <section ids="preemptive-actions" names="preemptive\ actions">
                <title>Preemptive actions</title>
                <paragraph>Action classes which have their <reference internal="True" reftitle="horizon.tables.Action.preempt" refuri="../ref/tables#horizon.tables.Action.preempt"><literal classes="xref py py-attr">preempt</literal></reference>
                    attribute set to <literal>True</literal> will be evaluated before any data is loaded into
                    the table. As such, you must be careful not to rely on any table methods that
                    require data, such as <reference internal="True" reftitle="horizon.tables.DataTable.get_object_display" refuri="../ref/tables#horizon.tables.DataTable.get_object_display"><literal classes="xref py py-meth">get_object_display()</literal></reference> or
                    <reference internal="True" reftitle="horizon.tables.DataTable.get_object_by_id" refuri="../ref/tables#horizon.tables.DataTable.get_object_by_id"><literal classes="xref py py-meth">get_object_by_id()</literal></reference>. The advantage of preemptive
                    actions is that you can avoid having to do all the processing, API calls, etc.
                    associated with loading data into the table for actions which don’t require
                    access to that information.</paragraph>
            </section>
            <section ids="policy-checks-on-actions" names="policy\ checks\ on\ actions">
                <title>Policy checks on actions</title>
                <paragraph>The <reference internal="True" reftitle="horizon.tables.Action.policy_rules" refuri="../ref/tables#horizon.tables.Action.policy_rules"><literal classes="xref py py-attr">policy_rules</literal></reference> attribute, when set, will
                    validate access to the action using the policy rules specified.  The attribute
                    is a list of scope/rule pairs.  Where the scope is the service type defining
                    the rule and the rule is a rule from the corresponding service policy.json
                    file.  The format of <reference internal="True" reftitle="horizon.tables.Action.policy_rules" refuri="../ref/tables#horizon.tables.Action.policy_rules"><literal classes="xref py py-attr">horizon.tables.Action.policy_rules</literal></reference> looks like:</paragraph>
                <literal_block xml:space="preserve">(("identity", "identity:get_user"),)</literal_block>
                <paragraph>Multiple checks can be made for the same action by merely adding more tuples
                    to the list.  The policy check will use information stored in the session
                    about the user and the result of
                    <literal classes="xref py py-meth">get_policy_target()</literal> (which can be overridden in
                    the derived action class) to determine if the user
                    can execute the action.  If the user does not have access to the action, the
                    action is not added to the table.</paragraph>
                <paragraph>If <reference internal="True" reftitle="horizon.tables.Action.policy_rules" refuri="../ref/tables#horizon.tables.Action.policy_rules"><literal classes="xref py py-attr">policy_rules</literal></reference> is not set, no policy checks
                    will be made to determine if the action should be visible and will be
                    displayed solely based on the result of
                    <literal classes="xref py py-meth">allowed()</literal>.</paragraph>
                <paragraph>For more information on policy based Role Based Access Control see
                    <reference internal="True" refuri="policy#topics-policy"><inline classes="std std-ref">Horizon Policy Enforcement (RBAC: Role Based Access Control)</inline></reference>.</paragraph>
            </section>
        </section>
        <section ids="table-cell-filters-decorators" names="table\ cell\ filters\ (decorators)">
            <title>Table Cell filters (decorators)</title>
            <paragraph>DataTable displays lists of objects in rows and object attributes in cell.
                How should we proceed, if we want to decorate some column, e.g. if we have
                column <literal>memory</literal> which returns a number e.g. 1024, and we want to show
                something like 1024.00 GB inside table?</paragraph>
            <section ids="decorator-pattern" names="decorator\ pattern">
                <title>Decorator pattern</title>
                <paragraph>The clear anti-pattern is defining the new attributes on object like
                    <literal>ram_float_format_2_gb</literal> or to tweak a DataTable in any way for displaying
                    purposes.</paragraph>
                <paragraph>The cleanest way is to use <literal>filters</literal>. Filters are decorators, following GOF
                    <literal>Decorator pattern</literal>. This way <literal>DataTable logic</literal> and <literal>displayed object
logic</literal> are correctly separated from <literal>presentation logic</literal> of the object
                    inside of the various tables. And therefore the filters are reusable in all
                    tables.</paragraph>
            </section>
            <section ids="filter-function" names="filter\ function">
                <title>Filter function</title>
                <paragraph>Horizon DatablesTable takes a tuple of pointers to filter functions
                    or anonymous lambda functions. When displaying a <literal>Cell</literal>, <literal>DataTable</literal>
                    takes <literal>Column</literal> filter functions from left to right, using the returned value
                    of the previous function as a parameter of the following function. Then
                    displaying the returned value of the last filter function.</paragraph>
                <paragraph>A valid filter function takes one parameter and returns the decorated value.
                    So e.g. these are valid filter functions</paragraph>
                <literal_block xml:space="preserve"># Filter function.
def add_unit(v):
  return str(v) + " GB"

# Or filter lambda function.
lambda v: str(v) + " GB"

# This is also a valid definition of course, although for the change of the
# unit parameter, function has to be wrapped by lambda
# (e.g. floatformat function example below).
def add_unit(v, unit="GB"):
  return str(v) + " " + unit</literal_block>
            </section>
            <section ids="using-filters-in-datatable-column" names="using\ filters\ in\ datatable\ column">
                <title>Using filters in DataTable column</title>
                <paragraph>DataTable takes tuple of filter functions, so e.g. this is valid decorating
                    of a value with float format and with unit</paragraph>
                <literal_block xml:space="preserve">ram = tables.Column(
    "ram",
    verbose_name=_('Memory'),
    filters=(lambda v: floatformat(v, 2),
             add_unit))</literal_block>
                <paragraph>It always takes tuple, so using only one filter would look like this</paragraph>
                <literal_block xml:space="preserve">filters=(lambda v: floatformat(v, 2),)</literal_block>
                <paragraph>The decorated parameter doesn’t have to be only a string or number, it can
                    be anything e.g. list or an object. So decorating of object, that has
                    attributes value and unit would look like this</paragraph>
                <literal_block xml:space="preserve">ram = tables.Column(
        "ram",
        verbose_name=_('Memory'),
        filters=(lambda x: getattr(x, 'value', '') +
                 " " + getattr(x, 'unit', ''),))</literal_block>
            </section>
            <section ids="available-filters" names="available\ filters">
                <title>Available filters</title>
                <paragraph>There are a load of filters, that can be used, defined in django already:
                    <reference refuri="https://github.com/django/django/blob/master/django/template/defaultfilters.py">https://github.com/django/django/blob/master/django/template/defaultfilters.py</reference></paragraph>
                <paragraph>So it’s enough to just import and use them, e.g.</paragraph>
                <literal_block xml:space="preserve">from django.template import defaultfilters as filters

# code omitted
filters=(filters.yesno, filters.capfirst)


from django.template.defaultfilters import timesince
from django.template.defaultfilters import title

# code omitted
filters=(parse_isotime, timesince)</literal_block>
            </section>
        </section>
        <section ids="inline-editing" names="inline\ editing">
            <title>Inline editing</title>
            <paragraph>Table cells can be easily upgraded with in-line editing. With use of
                django.form.Field, we are able to run validations of the field and correctly
                parse the data. The updating process is fully encapsulated into table
                functionality, communication with the server goes through AJAX in JSON format.
                The javascript wrapper for inline editing allows each table cell that has
                in-line editing available to:</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>Refresh itself with new data from the server.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Display in edit mode.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Send changed data to server.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Display validation errors.</paragraph>
                </list_item>
            </enumerated_list>
            <paragraph>There are basically 3 things that need to be defined in the table in order
                to enable in-line editing.</paragraph>
            <section ids="fetching-the-row-data" names="fetching\ the\ row\ data">
                <title>Fetching the row data</title>
                <paragraph>Defining an <literal>get_data</literal> method in a class inherited from <literal>tables.Row</literal>.
                    This method takes care of fetching the row data. This class has to be then
                    defined in the table Meta class as <literal>row_class = UpdateRow</literal>.</paragraph>
                <paragraph>Example:</paragraph>
                <literal_block xml:space="preserve">class UpdateRow(tables.Row):
    # this method is also used for automatic update of the row
    ajax = True

    def get_data(self, request, project_id):
        # getting all data of all row cells
        project_info = api.keystone.tenant_get(request, project_id,
                                               admin=True)
        return project_info</literal_block>
            </section>
            <section ids="updating-changed-cell-data-deprecated" names="updating\ changed\ cell\ data\ (deprecated)">
                <title>Updating changed cell data (DEPRECATED)</title>
                <paragraph>Define an <literal>update_cell</literal> method in the class inherited from
                    <literal>tables.UpdateAction</literal>. This method takes care of saving the data of the
                    table cell. There can be one class for every cell thanks to the
                    <literal>cell_name</literal> parameter. This class is then defined in tables column as
                    <literal>update_action=UpdateCell</literal>, so each column can have its own updating
                    method.</paragraph>
                <paragraph>Example:</paragraph>
                <literal_block xml:space="preserve">class UpdateCell(tables.UpdateAction):
    def allowed(self, request, project, cell):
        # Determines whether given cell or row will be inline editable
        # for signed in user.
        return api.keystone.keystone_can_edit_project()

    def update_cell(self, request, project_id, cell_name, new_cell_value):
        # in-line update project info
        try:
            project_obj = datum
            # updating changed value by new value
            setattr(project_obj, cell_name, new_cell_value)

            # sending new attributes back to API
            api.keystone.tenant_update(
                request,
                project_id,
                name=project_obj.name,
                description=project_obj.description,
                enabled=project_obj.enabled)

        except Conflict:
            # Validation error for naming conflict, raised when user
            # choose the existing name. We will raise a
            # ValidationError, that will be sent back to the client
            # browser and shown inside of the table cell.
            message = _("This name is already taken.")
            raise ValidationError(message)
        except:
            # Other exception of the API just goes through standard
            # channel
            exceptions.handle(request, ignore=True)
            return False
        return True</literal_block>
            </section>
            <section ids="defining-a-form-field-for-each-column-that-we-want-to-be-in-line-edited" names="defining\ a\ form_field\ for\ each\ column\ that\ we\ want\ to\ be\ in-line\ edited.">
                <title>Defining a form_field for each Column that we want to be in-line edited.</title>
                <paragraph>Form field should be <literal>django.form.Field</literal> instance, so we can use django
                    validations and parsing of the values sent by POST (in example validation
                    <literal>required=True</literal> and correct parsing of the checkbox value from the POST
                    data).</paragraph>
                <paragraph>Form field can be also <literal>django.form.Widget</literal> class, if we need to just
                    display the form widget in the table and we don’t need Field functionality.</paragraph>
                <paragraph>Then connecting <literal>UpdateRow</literal> and <literal>UpdateCell</literal> classes to the table.</paragraph>
                <paragraph>Example:</paragraph>
                <literal_block xml:space="preserve">class TenantsTable(tables.DataTable):
    # Adding html text input for inline editing, with required validation.
    # HTML form input will have a class attribute tenant-name-input, we
    # can define here any HTML attribute we need.
    name = tables.Column('name', verbose_name=_('Name'),
                         form_field=forms.CharField(required=True),
                         form_field_attributes={'class':'tenant-name-input'},
                         update_action=UpdateCell)

    # Adding html textarea without required validation.
    description = tables.Column(lambda obj: getattr(obj, 'description', None),
                                verbose_name=_('Description'),
                                form_field=forms.CharField(
                                    widget=forms.Textarea(),
                                    required=False),
                                update_action=UpdateCell)

    # Id will not be inline edited.
    id = tables.Column('id', verbose_name=_('Project ID'))

    # Adding html checkbox, that will be shown inside of the table cell with
    # label
    enabled = tables.Column('enabled', verbose_name=_('Enabled'), status=True,
                            form_field=forms.BooleanField(
                                label=_('Enabled'),
                                required=False),
                            update_action=UpdateCell)

    class Meta(object):
        name = "tenants"
        verbose_name = _("Projects")
        # Connection to UpdateRow, so table can fetch row data based on
        # their primary key.
        row_class = UpdateRow</literal_block>
            </section>
        </section>
    </section>
</document>
