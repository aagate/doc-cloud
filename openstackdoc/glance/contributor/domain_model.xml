<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document source="/home/fbaumanis/openstack/soc8_test/openstack_repo/glance/doc/source/contributor/domain_model.rst">
    <comment xml:space="preserve">Copyright 2015 OpenStack Foundation
All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License"); you may
not use this file except in compliance with the License. You may obtain
a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations
under the License.</comment>
    <section ids="domain-model" names="domain\ model">
        <title>Domain model</title>
        <paragraph>The main goal of a domain model is refactoring the logic around
            object manipulation by splitting it to independent layers. Each
            subsequent layer wraps the previous one creating an “onion” structure,
            thus realizing a design pattern called “Decorator.” The main feature
            of domain model is to use a composition instead of inheritance or
            basic decoration while building an architecture. This provides
            flexibility and transparency of an internal organization for a developer,
            because he does not know what layers are used and works with a domain
            model object as with a common object.</paragraph>
        <section ids="inner-architecture" names="inner\ architecture">
            <title>Inner architecture</title>
            <paragraph>Each layer defines its own operations’ implementation through a
                special <literal>proxy</literal> class. At first, operations are performed on the
                upper layer, then they successively pass the control to the underlying
                layers.</paragraph>
            <paragraph>The nesting of layers can be specified explicitly using a programmer
                interface Gateway or implicitly using <literal>helper</literal> classes. Nesting
                may also depend on various conditions, skipping or adding additional
                layers during domain object creation.</paragraph>
        </section>
        <section ids="proxies" names="proxies">
            <title>Proxies</title>
            <paragraph>The layer behavior is described in special <literal>proxy</literal> classes
                that must provide exactly the same interface as the original class
                does. In addition, each <literal>proxy</literal> class has a field <literal>base</literal>
                indicating a lower layer object that is an instance of another
                <literal>proxy</literal> or <literal>original</literal> class.</paragraph>
            <paragraph>To access the rest of the fields, you can use special <literal>proxy</literal>
                properties or universal methods <literal>set_property</literal> and <literal>get_property</literal>.</paragraph>
            <paragraph>In addition, the <literal>proxy</literal> class must have an <literal>__init__</literal> format
                method:</paragraph>
            <literal_block xml:space="preserve">def __init__(self, base, helper_class=None, helper_kwargs=None, **kwargs)</literal_block>
            <paragraph>where <literal>base</literal> corresponds to the underlying object layer,
                <literal>proxy_class</literal> and <literal>proxy_kwargs</literal> are optional and are used to
                create a <literal>helper</literal> class.
                Thus, to access a <literal>meth1</literal> method from the underlying layer, it is
                enough to call it on the <literal>base</literal> object:</paragraph>
            <literal_block xml:space="preserve">def meth1(*args, **kwargs):
        …
        self.base.meth1(*args, **kwargs)
        …</literal_block>
            <paragraph>To get access to the domain object field, it is recommended to use
                properties that are created by an auxiliary function:</paragraph>
            <literal_block xml:space="preserve">def _create_property_proxy(attr):
    def get_attr(self):
        return getattr(self.base, attr)

    def set_attr(self, value):
        return setattr(self.base, attr, value)

    def del_attr(self):
        return delattr(self.base, attr)

    return property(get_attr, set_attr, del_attr)</literal_block>
            <paragraph>So, the reference to the underlying layer field <literal>prop1</literal> looks like:</paragraph>
            <literal_block xml:space="preserve">class Proxy(object):
        …
        prop1 = _create_property_proxy('prop1')
        …</literal_block>
            <paragraph>If the number of layers is big, it is reasonable to create a common
                parent <literal>proxy</literal> class that provides further control transfer. This
                facilitates the writing of specific layers if they do not provide a
                particular implementation of some operation.</paragraph>
        </section>
        <section ids="gateway" names="gateway">
            <title>Gateway</title>
            <paragraph><literal>gateway</literal> is a mechanism to explicitly specify a composition of
                the domain model layers. It defines an interface to retrieve the
                domain model object based on the <literal>proxy</literal> classes described above.</paragraph>
            <section ids="example-of-the-gateway-implementation" names="example\ of\ the\ gateway\ implementation">
                <title>Example of the gateway implementation</title>
                <paragraph>This example defines three classes:</paragraph>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph><literal>Base</literal> is the main class that sets an interface for all the
                            <literal>proxy</literal> classes.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>LoggerProxy</literal> class implements additional logic associated with
                            the logging of messages from the <literal>print_msg</literal> method.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>ValidatorProxy</literal> class implements an optional check that helps to
                            determine whether all the parameters in the <literal>sum_numbers</literal> method
                            are positive.</paragraph>
                    </list_item>
                </bullet_list>
                <literal_block xml:space="preserve">class Base(object):
    ""Base class in domain model."""
    msg = "Hello Domain"

    def print_msg(self):
        print(self.msg)

    def sum_numbers(self, *args):
        return sum(args)

class LoggerProxy(object):
    """"Class extends functionality by writing message to log."""
    def __init__(self, base, logg):
        self.base = base
        self.logg = logg

    # Proxy to provide implicit access to inner layer.
    msg = _create_property_proxy('msg')

    def print_msg(self):
        # Write message to log and then pass the control to inner layer.
        self.logg.write("Message %s has been written to the log") % self.msg
        self.base.print_msg()

    def sum_numbers(self, *args):
        # Nothing to do here. Just pass the control to the next layer.
        return self.base.sum_numbers(*args)

class ValidatorProxy(object):
    """Class validates that input parameters are correct."""
    def __init__(self, base):
        self.base = base

    msg = _create_property_proxy('msg')

    def print_msg(self):
        # There are no checks.
        self.base.print_msg()

    def sum_numbers(self, *args):
        # Validate input numbers and pass them further.
        for arg in args:
            if arg &lt;= 0:
                return "Only positive numbers are supported."
        return self.base.sum_numbers(*args)</literal_block>
                <paragraph>Thus, the <literal>gateway</literal> method for the above example may look like:</paragraph>
                <literal_block xml:space="preserve">def gateway(logg, only_positive=True):
    base = Base()
    logger = LoggerProxy(base, logg)
    if only_positive:
        return ValidatorProxy(logger)
    return logger

domain_object = gateway(sys.stdout, only_positive=True)</literal_block>
                <paragraph>It is important to consider that the order of the layers matters.
                    And even if layers are logically independent from each other,
                    rearranging them in different order may lead to another result.</paragraph>
            </section>
        </section>
        <section ids="helpers" names="helpers">
            <title>Helpers</title>
            <paragraph><literal>Helper</literal> objects are used for an implicit nesting assignment that
                is based on a specification described in an auxiliary method (similar
                to <literal>gateway</literal>). This approach may be helpful when using a <emphasis>simple
                    factory</emphasis> for generating objects. Such a way is more flexible as it
                allows specifying the wrappers dynamically.</paragraph>
            <paragraph>The <literal>helper</literal> class is unique for all the <literal>proxy</literal> classes and it
                has the following form:</paragraph>
            <literal_block xml:space="preserve">class Helper(object):
    def __init__(self, proxy_class=None, proxy_kwargs=None):
        self.proxy_class = proxy_class
        self.proxy_kwargs = proxy_kwargs or {}

    def proxy(self, obj):
        """Wrap an object."""
        if obj is None or self.proxy_class is None:
            return obj
        return self.proxy_class(obj, **self.proxy_kwargs)

    def unproxy(self, obj):
        """Return object from inner layer."""
        if obj is None or self.proxy_class is None:
            return obj
        return obj.base</literal_block>
            <section ids="example-of-a-simple-factory-implementation" names="example\ of\ a\ simple\ factory\ implementation">
                <title>Example of a simple factory implementation</title>
                <paragraph>Here is a code of a <emphasis>simple factory</emphasis> for generating objects from the
                    previous example. It specifies a <literal>BaseFactory</literal> class with a
                    <literal>generate</literal> method and related <literal>proxy</literal> classes:</paragraph>
                <literal_block xml:space="preserve">class BaseFactory(object):
    """Simple factory to generate an object."""
    def generate(self):
        return Base()

class LoggerFactory(object):
    """Proxy class to add logging functionality."""
    def __init__(self, base, logg, proxy_class=None, proxy_kwargs=None):
        self.helper = Helper(proxy_class, proxy_kwargs)
        self.base = base
        self.logg = logg

    def generate(self):
        return self.helper.proxy(self.base.generate())

class ValidatorFactory(object):
    """Proxy class to add validation."""
    def __init__(self, base, only_positive=True, proxy_class=None, proxy_kwargs=None):
        self.helper = Helper(proxy_class, proxy_kwargs)
        self.base = base
        self.only_positive = only_positive

    def generate(self):
        if self.only_positive:
            # Wrap in ValidatorProxy if required.
            return self.helper.proxy(self.base.generate())
        return self.base.generate()</literal_block>
                <paragraph>Further, <literal>BaseFactory</literal> and related <literal>proxy</literal> classes are combined
                    together:</paragraph>
                <literal_block xml:space="preserve">def create_factory(logg, only_positive=True):
    base_factory = BaseFactory()
    logger_factory = LoggerFactory(base_factory, logg,
                                   proxy_class=LoggerProxy,
                                   proxy_kwargs=dict(logg=logg))
    validator_factory = ValidatorFactory(logger_factory, only_positive,
                                         proxy_class = ValidatorProxy)
    return validator_factory</literal_block>
                <paragraph>Ultimately, to generate a domain object, you create and run a factory
                    method <literal>generate</literal> which implicitly creates a composite object. This
                    method is based on specifications that are set forth in the <literal>proxy</literal>
                    class.</paragraph>
                <literal_block xml:space="preserve">factory = create_factory(sys.stdout, only_positive=False)
domain_object = factory.generate()</literal_block>
            </section>
        </section>
        <section ids="why-do-you-need-a-domain-if-you-can-use-decorators" names="why\ do\ you\ need\ a\ domain\ if\ you\ can\ use\ decorators?">
            <title>Why do you need a domain if you can use decorators?</title>
            <paragraph>In the above examples, to implement the planned logic, it is quite
                possible to use standard Python language techniques such as
                decorators. However, to implement more complicated operations, the
                domain model is reasonable and justified.</paragraph>
            <paragraph>In general, the domain is useful when:</paragraph>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph>there are more than three layers. In such case, the domain model
                        usage facilitates the understanding and supporting of the code;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>wrapping must be implemented depending on some conditions,
                        including dynamic wrapping;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>there is a requirement to wrap objects implicitly by helpers.</paragraph>
                </list_item>
            </bullet_list>
        </section>
    </section>
</document>
