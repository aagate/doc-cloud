<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document source="/home/fbaumanis/openstack/soc8_test/openstack_repo/glance/doc/source/admin/troubleshooting.rst">
    <section ids="images-and-instances" names="images\ and\ instances">
        <title>Images and instances</title>
        <paragraph>Virtual machine images contain a virtual disk that holds a
            bootable operating system on it. Disk images provide templates for
            virtual machine file systems. The Image service controls image storage
            and management.</paragraph>
        <paragraph>Instances are the individual virtual machines that run on physical
            compute nodes inside the cloud. Users can launch any number of instances
            from the same image. Each launched instance runs from a copy of the
            base image. Any changes made to the instance do not affect
            the base image. Snapshots capture the state of an instances
            running disk. Users can create a snapshot, and build a new image based
            on these snapshots. The Compute service controls instance, image, and
            snapshot storage and management.</paragraph>
        <paragraph>When you launch an instance, you must choose a <literal>flavor</literal>, which
            represents a set of virtual resources. Flavors define virtual
            CPU number, RAM amount available, and ephemeral disks size. Users
            must select from the set of available flavors
            defined on their cloud. OpenStack provides a number of predefined
            flavors that you can edit or add to.</paragraph>
        <note>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>For more information about creating and troubleshooting images,
                        see the <reference name="OpenStack Virtual Machine Image Guide" refuri="https://docs.openstack.org/image-guide/">OpenStack Virtual Machine Image
                            Guide</reference>.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>For more information about image configuration options, see the
                        <reference name="Image services" refuri="https://docs.openstack.org/ocata/config-reference/image.html">Image services</reference>
                        section of the OpenStack Configuration Reference.</paragraph>
                </list_item>
            </bullet_list>
        </note>
        <paragraph>You can add and remove additional resources from running instances, such
            as persistent volume storage, or public IP addresses. The example used
            in this chapter is of a typical virtual system within an OpenStack
            cloud. It uses the <literal>cinder-volume</literal> service, which provides persistent
            block storage, instead of the ephemeral storage provided by the selected
            instance flavor.</paragraph>
        <paragraph>This diagram shows the system state prior to launching an instance. The
            image store has a number of predefined images, supported by the Image
            service. Inside the cloud, a compute node contains the
            available vCPU, memory, and local disk resources. Additionally, the
            <literal>cinder-volume</literal> service stores predefined volumes.</paragraph>
        <line_block>
            <line></line>
        </line_block>
        <target refid="figure-base-image"></target>
        <paragraph ids="figure-base-image" names="figure\ base\ image"><strong>The base image state with no running instances</strong></paragraph>
        <figure>
            <image candidates="{'*': u'admin/../images/instance-life-1.png'}" uri="admin/../images/instance-life-1.png"></image>
        </figure>
        <line_block>
            <line></line>
        </line_block>
        <section ids="instance-launch" names="instance\ launch">
            <title>Instance Launch</title>
            <paragraph>To launch an instance, select an image, flavor, and any optional
                attributes. The selected flavor provides a root volume, labeled <literal>vda</literal>
                in this diagram, and additional ephemeral storage, labeled <literal>vdb</literal>. In
                this example, the <literal>cinder-volume</literal> store is mapped to the third virtual
                disk on this instance, <literal>vdc</literal>.</paragraph>
            <line_block>
                <line></line>
            </line_block>
            <target refid="figure-instance-creation"></target>
            <paragraph ids="figure-instance-creation" names="figure\ instance\ creation"><strong>Instance creation from an image</strong></paragraph>
            <figure>
                <image candidates="{'*': u'admin/../images/instance-life-2.png'}" uri="admin/../images/instance-life-2.png"></image>
            </figure>
            <line_block>
                <line></line>
            </line_block>
            <paragraph>The Image service copies the base image from the image store to the
                local disk. The local disk is the first disk that the instance
                accesses, which is the root volume labeled <literal>vda</literal>. Smaller
                instances start faster. Less data needs to be copied across
                the network.</paragraph>
            <paragraph>The new empty ephemeral disk is also created, labeled <literal>vdb</literal>.
                This disk is deleted when you delete the instance.</paragraph>
            <paragraph>The compute node connects to the attached <literal>cinder-volume</literal> using iSCSI. The
                <literal>cinder-volume</literal> is mapped to the third disk, labeled <literal>vdc</literal> in this
                diagram. After the compute node provisions the vCPU and memory
                resources, the instance boots up from root volume <literal>vda</literal>. The instance
                runs and changes data on the disks (highlighted in red on the diagram).
                If the volume store is located on a separate network, the
                <literal>my_block_storage_ip</literal> option specified in the storage node
                configuration file directs image traffic to the compute node.</paragraph>
            <note>
                <paragraph>Some details in this example scenario might be different in your
                    environment. For example, you might use a different type of back-end
                    storage, or different network protocols. One common variant is that
                    the ephemeral storage used for volumes <literal>vda</literal> and <literal>vdb</literal> could be
                    backed by network storage rather than a local disk.</paragraph>
            </note>
            <paragraph>When you delete an instance, the state is reclaimed with the exception
                of the persistent volume. The ephemeral storage, whether encrypted or not,
                is purged. Memory and vCPU resources are released. The image remains
                unchanged throughout this process.</paragraph>
            <line_block>
                <line></line>
            </line_block>
            <target refid="end-of-state"></target>
            <paragraph ids="end-of-state" names="end\ of\ state"><strong>The end state of an image and volume after the instance exits</strong></paragraph>
            <figure>
                <image candidates="{'*': u'admin/../images/instance-life-3.png'}" uri="admin/../images/instance-life-3.png"></image>
            </figure>
            <line_block>
                <line></line>
            </line_block>
        </section>
        <section ids="image-properties-and-property-protection" names="image\ properties\ and\ property\ protection">
            <title>Image properties and property protection</title>
            <paragraph>An image property is a key and value pair that the administrator
                or the image owner attaches to an OpenStack Image service image, as
                follows:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>The administrator defines core properties, such as the image
                        name.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The administrator and the image owner can define additional
                        properties, such as licensing and billing information.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>The administrator can configure any property as protected, which
                limits which policies or user roles can perform CRUD operations on that
                property. Protected properties are generally additional properties to
                which only administrators have access.</paragraph>
            <paragraph>For unprotected image properties, the administrator can manage
                core properties and the image owner can manage additional properties.</paragraph>
            <paragraph><strong>To configure property protection</strong></paragraph>
            <paragraph>To configure property protection, edit the <literal>policy.json</literal> file. This file
                can also be used to set policies for Image service actions.</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>Define roles or policies in the <literal>policy.json</literal> file:</paragraph>
                    <literal_block highlight_args="{}" language="json" linenos="False" xml:space="preserve">{
    "context_is_admin":  "role:admin",
    "default": "",

    "add_image": "",
    "delete_image": "",
    "get_image": "",
    "get_images": "",
    "modify_image": "",
    "publicize_image": "role:admin",
    "copy_from": "",

    "download_image": "",
    "upload_image": "",

    "delete_image_location": "",
    "get_image_location": "",
    "set_image_location": "",

    "add_member": "",
    "delete_member": "",
    "get_member": "",
    "get_members": "",
    "modify_member": "",

    "manage_image_cache": "role:admin",

    "get_task": "",
    "get_tasks": "",
    "add_task": "",
    "modify_task": "",

    "deactivate": "",
    "reactivate": "",

    "get_metadef_namespace": "",
    "get_metadef_namespaces":"",
    "modify_metadef_namespace":"",
    "add_metadef_namespace":"",
    "delete_metadef_namespace":"",

    "get_metadef_object":"",
    "get_metadef_objects":"",
    "modify_metadef_object":"",
    "add_metadef_object":"",

    "list_metadef_resource_types":"",
    "get_metadef_resource_type":"",
    "add_metadef_resource_type_association":"",

    "get_metadef_property":"",
    "get_metadef_properties":"",
    "modify_metadef_property":"",
    "add_metadef_property":"",

    "get_metadef_tag":"",
    "get_metadef_tags":"",
    "modify_metadef_tag":"",
    "add_metadef_tag":"",
    "add_metadef_tags":""
 }</literal_block>
                    <paragraph>For each parameter, use <literal>"rule:restricted"</literal> to restrict access to all
                        users or <literal>"role:admin"</literal> to limit access to administrator roles.
                        For example:</paragraph>
                    <literal_block highlight_args="{}" language="json" linenos="False" xml:space="preserve">{
"download_image":
"upload_image":
}</literal_block>
                </list_item>
                <list_item>
                    <paragraph>Define which roles or policies can manage which properties in a property
                        protections configuration file. For example:</paragraph>
                    <literal_block highlight_args="{}" language="ini" linenos="False" xml:space="preserve">[x_none_read]
create = context_is_admin
read = !
update = !
delete = !

[x_none_update]
create = context_is_admin
read = context_is_admin
update = !
delete = context_is_admin

[x_none_delete]
create = context_is_admin
read = context_is_admin
update = context_is_admin
delete = !</literal_block>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph>A value of <literal>@</literal> allows the corresponding operation for a property.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>A value of <literal>!</literal> disallows the corresponding operation for a
                                property.</paragraph>
                        </list_item>
                    </bullet_list>
                </list_item>
                <list_item>
                    <paragraph>In the <literal>glance-api.conf</literal> file, define the location of a property
                        protections configuration file.</paragraph>
                    <literal_block highlight_args="{}" language="ini" linenos="False" xml:space="preserve">property_protection_file = {file_name}</literal_block>
                    <paragraph>This file contains the rules for property protections and the roles and
                        policies associated with it.</paragraph>
                    <paragraph>By default, property protections are not enforced.</paragraph>
                    <paragraph>If you specify a file name value and the file is not found, the
                        <literal>glance-api</literal> service does not start.</paragraph>
                    <paragraph>To view a sample configuration file, see
                        <reference name="glance-api.conf" refuri="https://docs.openstack.org/ocata/config-reference/image/glance-api.conf.html">glance-api.conf</reference>.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Optionally, in the <literal>glance-api.conf</literal> file, specify whether roles or
                        policies are used in the property protections configuration file</paragraph>
                    <literal_block highlight_args="{}" language="ini" linenos="False" xml:space="preserve">property_protection_rule_format = roles</literal_block>
                    <paragraph>The default is <literal>roles</literal>.</paragraph>
                    <paragraph>To view a sample configuration file, see
                        <reference name="glance-api.conf" refuri="https://docs.openstack.org/ocata/config-reference/image/glance-api.conf.html">glance-api.conf</reference>.</paragraph>
                </list_item>
            </enumerated_list>
        </section>
        <section ids="image-download-how-it-works" names="image\ download:\ how\ it\ works">
            <title>Image download: how it works</title>
            <paragraph>Prior to starting a virtual machine, transfer the virtual machine image
                to the compute node from the Image service. How this
                works can change depending on the settings chosen for the compute node
                and the Image service.</paragraph>
            <paragraph>Typically, the Compute service will use the image identifier passed to
                it by the scheduler service and request the image from the Image API.
                Though images are not stored in glance—rather in a back end, which could
                be Object Storage, a filesystem or any other supported method—the
                connection is made from the compute node to the Image service and the
                image is transferred over this connection. The Image service streams the
                image from the back end to the compute node.</paragraph>
            <paragraph>It is possible to set up the Object Storage node on a separate network,
                and still allow image traffic to flow between the compute and object
                storage nodes. Configure the <literal>my_block_storage_ip</literal> option in the
                storage node configuration file to allow block storage traffic to reach
                the compute node.</paragraph>
            <paragraph>Certain back ends support a more direct method, where on request the
                Image service will return a URL that links directly to the back-end store.
                You can download the image using this approach. Currently, the only store
                to support the direct download approach is the filesystem store.
                Configured the approach using the <literal>filesystems</literal> option in
                the <literal>image_file_url</literal> section of the <literal>nova.conf</literal> file on
                compute nodes.</paragraph>
            <paragraph>Compute nodes also implement caching of images, meaning that if an image
                has been used before it won’t necessarily be downloaded every time.
                Information on the configuration options for caching on compute nodes
                can be found in the <reference name="Configuration Reference" refuri="https://docs.openstack.org/ocata/config-reference/">Configuration
                    Reference</reference>.</paragraph>
        </section>
        <section ids="instance-building-blocks" names="instance\ building\ blocks">
            <title>Instance building blocks</title>
            <paragraph>In OpenStack, the base operating system is usually copied from an image
                stored in the OpenStack Image service. This results in an ephemeral
                instance that starts from a known template state and loses all
                accumulated states on shutdown.</paragraph>
            <paragraph>You can also put an operating system on a persistent volume in Compute
                or the Block Storage volume system. This gives a more traditional,
                persistent system that accumulates states that are preserved across
                restarts. To get a list of available images on your system, run:</paragraph>
            <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve">$ openstack image list
+--------------------------------------+-----------------------------+--------+
| ID                                   | Name                        | Status |
+--------------------------------------+-----------------------------+--------+
| aee1d242-730f-431f-88c1-87630c0f07ba | Ubuntu 14.04 cloudimg amd64 | active |
+--------------------------------------+-----------------------------+--------+
| 0b27baa1-0ca6-49a7-b3f4-48388e440245 | Ubuntu 14.10 cloudimg amd64 | active |
+--------------------------------------+-----------------------------+--------+
| df8d56fc-9cea-4dfd-a8d3-28764de3cb08 | jenkins                     | active |
+--------------------------------------+-----------------------------+--------+</literal_block>
            <paragraph>The displayed image attributes are:</paragraph>
            <definition_list>
                <definition_list_item>
                    <term><literal>ID</literal></term>
                    <definition>
                        <paragraph>Automatically generated UUID of the image.</paragraph>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term><literal>Name</literal></term>
                    <definition>
                        <paragraph>Free form, human-readable name for the image.</paragraph>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term><literal>Status</literal></term>
                    <definition>
                        <paragraph>The status of the image. Images marked <literal>ACTIVE</literal> are available for
                            use.</paragraph>
                    </definition>
                </definition_list_item>
                <definition_list_item>
                    <term><literal>Server</literal></term>
                    <definition>
                        <paragraph>For images that are created as snapshots of running instances, this
                            is the UUID of the instance the snapshot derives from. For uploaded
                            images, this field is blank.</paragraph>
                    </definition>
                </definition_list_item>
            </definition_list>
            <paragraph>Virtual hardware templates are called <literal>flavors</literal>, and are defined by
                administrators. Prior to the Newton release, a default installation also
                includes five predefined flavors.</paragraph>
            <paragraph>For a list of flavors that are available on your system, run:</paragraph>
            <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve">$ openstack flavor list
+-----+-----------+-------+------+-----------+-------+-----------+
| ID  | Name      |   RAM | Disk | Ephemeral | VCPUs | Is_Public |
+-----+-----------+-------+------+-----------+-------+-----------+
| 1   | m1.tiny   |   512 |    1 |         0 |     1 | True      |
| 2   | m1.small  |  2048 |   20 |         0 |     1 | True      |
| 3   | m1.medium |  4096 |   40 |         0 |     2 | True      |
| 4   | m1.large  |  8192 |   80 |         0 |     4 | True      |
| 5   | m1.xlarge | 16384 |  160 |         0 |     8 | True      |
+-----+-----------+-------+------+-----------+-------+-----------+</literal_block>
            <paragraph>By default, administrative users can configure the flavors. You can
                change this behavior by redefining the access controls for
                <literal>compute_extension:flavormanage</literal> in <literal>/etc/nova/policy.json</literal> on the
                <literal>compute-api</literal> server.</paragraph>
        </section>
        <section ids="instance-management-tools" names="instance\ management\ tools">
            <title>Instance management tools</title>
            <paragraph>OpenStack provides command-line, web interface, and API-based instance
                management tools. Third-party management tools are also available, using
                either the native API or the provided EC2-compatible API.</paragraph>
            <paragraph>The OpenStack python-openstackclient package provides a basic command-line
                utility, which uses the <literal_strong classes="command">openstack</literal_strong> command.
                This is available as a native package for most Linux distributions,
                or you can install the latest version using the pip python package installer:</paragraph>
            <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve"># pip install python-openstackclient</literal_block>
            <paragraph>For more information about python-openstackclient and other command-line
                tools, see the <reference name="OpenStack End User Guide" refuri="https://docs.openstack.org/user-guide/cli.html">OpenStack End User
                    Guide</reference>.</paragraph>
        </section>
        <section ids="control-where-instances-run" names="control\ where\ instances\ run">
            <title>Control where instances run</title>
            <paragraph>The <reference name="Scheduling section" refuri="https://docs.openstack.org/ocata/config-reference/compute/schedulers.html">Scheduling section</reference>
                of OpenStack Configuration Reference
                provides detailed information on controlling where your instances run,
                including ensuring a set of instances run on different compute nodes for
                service resiliency or on the same node for high performance
                inter-instance communications.</paragraph>
            <paragraph>Administrative users can specify which compute node their instances
                run on. To do this, specify the <literal>--availability-zone
AVAILABILITY_ZONE:COMPUTE_HOST</literal> parameter.</paragraph>
        </section>
        <section ids="launch-instances-with-uefi" names="launch\ instances\ with\ uefi">
            <title>Launch instances with UEFI</title>
            <paragraph>Unified Extensible Firmware Interface (UEFI) is a standard firmware
                designed to replace legacy BIOS. There is a slow but steady trend
                for operating systems to move to the UEFI format and, in some cases,
                make it their only format.</paragraph>
            <paragraph><strong>To configure UEFI environment</strong></paragraph>
            <paragraph>To successfully launch an instance from an UEFI image in QEMU/KVM
                environment, the administrator has to install the following
                packages on compute node:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>OVMF, a port of Intel’s tianocore firmware to QEMU virtual machine.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>libvirt, which has been supporting UEFI boot since version 1.2.9.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>Because default UEFI loader path is <literal>/usr/share/OVMF/OVMF_CODE.fd</literal>, the
                administrator must create one link to this location after UEFI package
                is installed.</paragraph>
            <paragraph><strong>To upload UEFI images</strong></paragraph>
            <paragraph>To launch instances from a UEFI image, the administrator first has to
                upload one UEFI image. To do so, <literal>hw_firmware_type</literal> property must
                be set to <literal>uefi</literal> when the image is created. For example:</paragraph>
            <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve">$ openstack image create --container-format bare --disk-format qcow2 \
  --property hw_firmware_type=uefi --file /tmp/cloud-uefi.qcow --name uefi</literal_block>
            <paragraph>After that, you can launch instances from this UEFI image.</paragraph>
        </section>
    </section>
</document>
